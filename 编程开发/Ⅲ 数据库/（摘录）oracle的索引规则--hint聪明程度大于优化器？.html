<!DOCTYPE html>
<html><head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">

<!--defaultCSS-->
<title>（摘录）oracle的索引规则--hint聪明程度大于优化器？</title>



<style type="text/css" id="wiz_custom_css">
body
{
    font-family: Microsoft YaHei UI,"Microsoft YaHei", Georgia,Helvetica,Arial,sans-serif,宋体, PMingLiU,serif;
    font-size: 10.5pt;
    line-height: 1.5;
}
html, body
{
    
    
}
h1 {
    font-size:1.5em;
    font-weight:bold;
}
h2 {
    font-size:1.4em;
    font-weight:bold;
}
h3 {
    font-size:1.3em;
    font-weight:bold;
}
h4 {
    font-size:1.2em;
    font-weight:bold;
}
h5 {
    font-size:1.1em;
    font-weight:bold;
}
h6 {
    font-size:1.0em;
    font-weight:bold;
}
img {
    border:0;
    max-width: 100%;
    height: auto !important;
}
blockquote {
    margin-top:0px;
    margin-bottom:0px;
}
table {
    border-collapse:collapse;
    border:1px solid #bbbbbb;
}
td {
    border-collapse:collapse;
    border:1px solid #bbbbbb;
}
</style>

<style type="text/css" id="wiz_todo_style_id" wiz_link_version="01.00.09">.wiz-todo, .wiz-todo-img {width: 16px; height: 16px; cursor: default; padding: 0 10px 0 2px; vertical-align: -10%;-webkit-user-select: none;} .wiz-todo-label { display: inline-block; padding-top: 7px; padding-bottom: 6px; line-height: 1.5;} .wiz-todo-label-checked {  color: #666;} .wiz-todo-label-unchecked {text-decoration: initial;} .wiz-todo-completed-info {padding-left: 44px; display: inline-block; } .wiz-todo-avatar { width:20px; height: 20px; vertical-align: -20%; margin-right:10px; border-radius: 2px;} .wiz-todo-account, .wiz-todo-dt { color: #666; }</style></head>

<body  style=""><h1 class="postTitle" style="font-size: 14.7px; margin-bottom: 10px; color: rgb(75, 75, 75); font-family: Verdana, Geneva, Arial, Helvetica, sans-serif; widows: 1;"><a id="cb_post_title_url" class="postTitle2" href="http://www.cnblogs.com/rootq/archive/2008/10/19/1314669.html" style="text-decoration: none; color: rgb(26, 139, 200);">Oracle中组合索引的使用详解</a></h1><div id="cnblogs_post_body" style="margin-bottom: 20px; word-break: break-word; color: rgb(75, 75, 75); font-family: Verdana, Geneva, Arial, Helvetica, sans-serif; font-size: 13px; line-height: 19.5px; widows: 1;"><p style="line-height: 1.5; margin: 10px auto;">在Oracle中可以创建组合索引，即同时包含两个或两个以上列的索引。在组合索引的使用方面，Oracle有以下特点：</p><p style="line-height: 1.5; margin: 10px auto;">&nbsp;&nbsp;&nbsp; 1、 当使用基于规则的优化器（RBO）时，只有当组合索引的前导列出现在SQL语句的where子句中时，才会使用到该索引；</p><p style="line-height: 1.5; margin: 10px auto;">&nbsp;&nbsp;&nbsp; 2、 在使用Oracle9i之前的基于成本的优化器（CBO）时， 只有当组合索引的前导列出现在SQL语句的where子句中时，才可能会使用到该索引，这取决于优化器计算的使用索引的成本和使用全表扫描的成本，Oracle会自动选择成本低的访问路径（请见下面的测试1和测试2）；</p><p style="line-height: 1.5; margin: 10px auto;">&nbsp;&nbsp;&nbsp; 3、 从Oracle9i起，Oracle引入了一种新的索引扫描方式——索引跳跃扫描（index skip scan），这种扫描方式只有基于成本的优化器（CBO）才能使用。这样，当SQL语句的where子句中即使没有组合索引的前导列，并且索引跳跃扫描的成本低于其他扫描方式的成本时，Oracle就会使用该方式扫描组合索引（请见下面的测试3）；</p><p style="line-height: 1.5; margin: 10px auto;">&nbsp;&nbsp;&nbsp; 4、 Oracle优化器有时会做出错误的选择，因为它再“聪明”，也不如我们SQL语句编写人员更清楚表中数据的分布，在这种情况下，通过使用提示（hint），我们可以帮助Oracle优化器作出更好的选择（请见下面的测试4）。</p><p style="line-height: 1.5; margin: 10px auto;">&nbsp;&nbsp;&nbsp; 关于以上情况，我们分别测试如下：</p><p style="line-height: 1.5; margin: 10px auto;">&nbsp;&nbsp;&nbsp; 我们创建测试表T，该表的数据来源于Oracle的数据字典表all_objects，表T的结构如下：</p><p style="line-height: 1.5; margin: 10px auto;">SQL&gt; desc t</p><p style="line-height: 1.5; margin: 10px auto;">名称 是否为空? 类型</p><p style="line-height: 1.5; margin: 10px auto;">----------------------------------------- -------- ---------------------</p><p style="line-height: 1.5; margin: 10px auto;">OWNER NOT NULL VARCHAR2(30)</p><p style="line-height: 1.5; margin: 10px auto;">OBJECT_NAME NOT NULL VARCHAR2(30)</p><p style="line-height: 1.5; margin: 10px auto;">SUBOBJECT_NAME VARCHAR2(30)</p><p style="line-height: 1.5; margin: 10px auto;">OBJECT_ID NOT NULL NUMBER</p><p style="line-height: 1.5; margin: 10px auto;">DATA_OBJECT_ID NUMBER</p><p style="line-height: 1.5; margin: 10px auto;">OBJECT_TYPE VARCHAR2(18)</p><p style="line-height: 1.5; margin: 10px auto;">CREATED NOT NULL DATE</p><p style="line-height: 1.5; margin: 10px auto;">LAST_DDL_TIME NOT NULL DATE</p><p style="line-height: 1.5; margin: 10px auto;">TIMESTAMP VARCHAR2(19)</p><p style="line-height: 1.5; margin: 10px auto;">STATUS VARCHAR2(7)</p><p style="line-height: 1.5; margin: 10px auto;">TEMPORARY VARCHAR2(1)</p><p style="line-height: 1.5; margin: 10px auto;">GENERATED VARCHAR2(1)</p><p style="line-height: 1.5; margin: 10px auto;">SECONDARY VARCHAR2(1)</p><p style="line-height: 1.5; margin: 10px auto;"><br>表中的数据分布情况如下：</p><p style="line-height: 1.5; margin: 10px auto;">SQL&gt; select object_type,count(*) from t group by object_type;</p><p style="line-height: 1.5; margin: 10px auto;">OBJECT_TYPE COUNT(*)</p><p style="line-height: 1.5; margin: 10px auto;">------------------ ----------</p><p style="line-height: 1.5; margin: 10px auto;">CONSUMER GROUP 20</p><p style="line-height: 1.5; margin: 10px auto;">EVALUATION CONTEXT 10</p><p style="line-height: 1.5; margin: 10px auto;">FUNCTION 360</p><p style="line-height: 1.5; margin: 10px auto;">INDEX 69</p><p style="line-height: 1.5; margin: 10px auto;">LIBRARY 20</p><p style="line-height: 1.5; margin: 10px auto;">LOB 20</p><p style="line-height: 1.5; margin: 10px auto;">OPERATOR 20</p><p style="line-height: 1.5; margin: 10px auto;">PACKAGE 1210</p><p style="line-height: 1.5; margin: 10px auto;">PROCEDURE 130</p><p style="line-height: 1.5; margin: 10px auto;">SYNONYM 16100</p><p style="line-height: 1.5; margin: 10px auto;">TABLE 180</p><p style="line-height: 1.5; margin: 10px auto;">TYPE 2750</p><p style="line-height: 1.5; margin: 10px auto;">VIEW 8600</p><p style="line-height: 1.5; margin: 10px auto;">已选择13行。</p><p style="line-height: 1.5; margin: 10px auto;">SQL&gt; select count(*) from t;</p><p style="line-height: 1.5; margin: 10px auto;">COUNT(*)</p><p style="line-height: 1.5; margin: 10px auto;">----------</p><p style="line-height: 1.5; margin: 10px auto;">29489</p><p style="line-height: 1.5; margin: 10px auto;">&nbsp;&nbsp;&nbsp; 我们在表T上创建如下索引并对其进行分析：</p><p style="line-height: 1.5; margin: 10px auto;">SQL&gt; create index indx_t on t(object_type,object_name);</p><p style="line-height: 1.5; margin: 10px auto;">索引已创建。</p><p style="line-height: 1.5; margin: 10px auto;">SQL&gt; ANALYZE TABLE T COMPUTE STATISTICS</p><p style="line-height: 1.5; margin: 10px auto;">2 FOR TABLE</p><p style="line-height: 1.5; margin: 10px auto;">3 FOR ALL INDEXES</p><p style="line-height: 1.5; margin: 10px auto;">4 FOR ALL INDEXED COLUMNS</p><p style="line-height: 1.5; margin: 10px auto;">5 /</p><p style="line-height: 1.5; margin: 10px auto;">表已分析。</p><p style="line-height: 1.5; margin: 10px auto;">现在让我们编写几条SQL语句来测试一下Oracle优化器对访问路径的选择：</p><p style="line-height: 1.5; margin: 10px auto;">&nbsp;&nbsp;&nbsp; 测试1）</p><p style="line-height: 1.5; margin: 10px auto;">SQL&gt; set autotrace traceonly</p><p style="line-height: 1.5; margin: 10px auto;">SQL&gt; SELECT * FROM T WHERE OBJECT_TYPE='LOB';</p><p style="line-height: 1.5; margin: 10px auto;">已选择20行。</p><p style="line-height: 1.5; margin: 10px auto;">Execution Plan</p><p style="line-height: 1.5; margin: 10px auto;">----------------------------------------------------------</p><p style="line-height: 1.5; margin: 10px auto;">0 SELECT STATEMENT Optimizer=CHOOSE (Cost=22 Card=20 Bytes=1740)</p><p style="line-height: 1.5; margin: 10px auto;">1 0 TABLE ACCESS (BY INDEX ROWID) OF 'T' (Cost=22 Card=20 Bytes=1740)</p><p style="line-height: 1.5; margin: 10px auto;">2 1 INDEX (RANGE SCAN) OF 'INDX_T' (NON-UNIQUE) (Cost=2 Card=20)</p><p style="line-height: 1.5; margin: 10px auto;">&nbsp;&nbsp;&nbsp; 正如我们所期望的，由于使用了组合索引的前导列并且访问了表中的少量记录，Oracle明智地选择了索引扫描。那么，如果我们访问表中的大量数据时，Oracle会选择什么样的访问路径呢？请看下面的测试：</p><p style="line-height: 1.5; margin: 10px auto;"><br>&nbsp;&nbsp;&nbsp; 测试2）</p><p style="line-height: 1.5; margin: 10px auto;">SQL&gt; SELECT * FROM T WHERE OBJECT_TYPE='SYNONYM';</p><p style="line-height: 1.5; margin: 10px auto;">已选择16100行。</p><p style="line-height: 1.5; margin: 10px auto;">Execution Plan</p><p style="line-height: 1.5; margin: 10px auto;">----------------------------------------------------------</p><p style="line-height: 1.5; margin: 10px auto;">0 SELECT STATEMENT Optimizer=CHOOSE (Cost=38 Card=16100 Bytes=1400700)</p><p style="line-height: 1.5; margin: 10px auto;">1 0 TABLE ACCESS (FULL) OF 'T' (Cost=38 Card=16100 Bytes=1400700)</p><p style="line-height: 1.5; margin: 10px auto;">Statistics</p><p style="line-height: 1.5; margin: 10px auto;">----------------------------------------------------------</p><p style="line-height: 1.5; margin: 10px auto;">0 recursive calls</p><p style="line-height: 1.5; margin: 10px auto;">0 db block gets</p><p style="line-height: 1.5; margin: 10px auto;">1438 consistent gets</p><p style="line-height: 1.5; margin: 10px auto;">13 physical reads</p><p style="line-height: 1.5; margin: 10px auto;">0 redo size</p><p style="line-height: 1.5; margin: 10px auto;">941307 bytes sent via SQL*Net to client</p><p style="line-height: 1.5; margin: 10px auto;">12306 bytes received via SQL*Net from client</p><p style="line-height: 1.5; margin: 10px auto;">1075 SQL*Net roundtrips to/from client</p><p style="line-height: 1.5; margin: 10px auto;">0 sorts (memory)</p><p style="line-height: 1.5; margin: 10px auto;">0 sorts (disk)</p><p style="line-height: 1.5; margin: 10px auto;">16100 rows processed</p><p style="line-height: 1.5; margin: 10px auto;">&nbsp;&nbsp;&nbsp; 很明显，即使使用了组合索引的前导列，但是由于访问了表中的大量数据，Oracle选择了不使用索引而直接使用全表扫描，因为优化器认为全表扫描的成本更低，但事实是不是真的这样的？我们通过增加提示（hint）来强制它使用索引来看看：</p><p style="line-height: 1.5; margin: 10px auto;"><br>SQL&gt; SELECT/**//*+ INDEX (T INDX_T)*/ * FROM T WHERE OBJECT_TYPE='SYNONYM';</p><p style="line-height: 1.5; margin: 10px auto;">已选择16100行。</p><p style="line-height: 1.5; margin: 10px auto;">Execution Plan</p><p style="line-height: 1.5; margin: 10px auto;">----------------------------------------------------------</p><p style="line-height: 1.5; margin: 10px auto;">0 SELECT STATEMENT Optimizer=CHOOSE (Cost=16180 Card=16100 Bytes=1400700)</p><p style="line-height: 1.5; margin: 10px auto;">1 0 TABLE ACCESS (BY INDEX ROWID) OF 'T' (Cost=16180 Card=16100 Bytes=1400700)</p><p style="line-height: 1.5; margin: 10px auto;">2 1 INDEX (RANGE SCAN) OF 'INDX_T' (NON-UNIQUE) (Cost=80 Card=16100)</p><p style="line-height: 1.5; margin: 10px auto;">Statistics</p><p style="line-height: 1.5; margin: 10px auto;">----------------------------------------------------------</p><p style="line-height: 1.5; margin: 10px auto;">0 recursive calls</p><p style="line-height: 1.5; margin: 10px auto;">0 db block gets</p><p style="line-height: 1.5; margin: 10px auto;">17253 consistent gets</p><p style="line-height: 1.5; margin: 10px auto;">16 physical reads</p><p style="line-height: 1.5; margin: 10px auto;">0 redo size</p><p style="line-height: 1.5; margin: 10px auto;">298734 bytes sent via SQL*Net to client</p><p style="line-height: 1.5; margin: 10px auto;">12306 bytes received via SQL*Net from client</p><p style="line-height: 1.5; margin: 10px auto;">1075 SQL*Net roundtrips to/from client</p><p style="line-height: 1.5; margin: 10px auto;">0 sorts (memory)</p><p style="line-height: 1.5; margin: 10px auto;">0 sorts (disk)</p><p style="line-height: 1.5; margin: 10px auto;">16100 rows processed</p><p style="line-height: 1.5; margin: 10px auto;">&nbsp;&nbsp;&nbsp; 从以上结果可以看出，在访问大量数据的情况下，使用索引确实会导致更高的执行成本，这从statistics部分的逻辑读取数（consistent gets）就可以看出，使用索引导致的逻辑读取数是不使用索引导致的逻辑读的10倍还多。因此，Oracle明智地选择了全表扫描而不是索引扫描。</p><p style="line-height: 1.5; margin: 10px auto;">下面，让我们来看看where子句中没有索引前导列的情况：</p><p style="line-height: 1.5; margin: 10px auto;"><br>&nbsp;&nbsp;&nbsp; 测试3）</p><p style="line-height: 1.5; margin: 10px auto;"><br>SQL&gt; select * from t where object_name= 'DEPT';</p><p style="line-height: 1.5; margin: 10px auto;">已选择10行。</p><p style="line-height: 1.5; margin: 10px auto;">Execution Plan</p><p style="line-height: 1.5; margin: 10px auto;">----------------------------------------------------------</p><p style="line-height: 1.5; margin: 10px auto;">0 SELECT STATEMENT Optimizer=CHOOSE (Cost=29 Card=14 Bytes=1218)</p><p style="line-height: 1.5; margin: 10px auto;">1 0 TABLE ACCESS (BY INDEX ROWID) OF 'T' (Cost=29 Card=14 Bytes=1218)</p><p style="line-height: 1.5; margin: 10px auto;">2 1 INDEX (SKIP SCAN) OF 'INDX_T' (NON-UNIQUE) (Cost=14 Card=14)</p><p style="line-height: 1.5; margin: 10px auto;">Statistics</p><p style="line-height: 1.5; margin: 10px auto;">----------------------------------------------------------</p><p style="line-height: 1.5; margin: 10px auto;">0 recursive calls</p><p style="line-height: 1.5; margin: 10px auto;">0 db block gets</p><p style="line-height: 1.5; margin: 10px auto;">24 consistent gets</p><p style="line-height: 1.5; margin: 10px auto;">0 physical reads</p><p style="line-height: 1.5; margin: 10px auto;">0 redo size</p><p style="line-height: 1.5; margin: 10px auto;">1224 bytes sent via SQL*Net to client</p><p style="line-height: 1.5; margin: 10px auto;">503 bytes received via SQL*Net from client</p><p style="line-height: 1.5; margin: 10px auto;">2 SQL*Net roundtrips to/from client</p><p style="line-height: 1.5; margin: 10px auto;">0 sorts (memory)</p><p style="line-height: 1.5; margin: 10px auto;">0 sorts (disk)</p><p style="line-height: 1.5; margin: 10px auto;">10 rows processed</p><p style="line-height: 1.5; margin: 10px auto;">&nbsp;&nbsp;&nbsp; OK！由于只查询了10条数据，即使没有使用前导列，Oracle正确地选择了索引跳跃扫描。我们再来看看如果不使用索引跳跃扫描，该语句的成本：</p><p style="line-height: 1.5; margin: 10px auto;">SQL&gt; select/**//*+ NO_INDEX(T INDX_T)*/ * from t where object_name= 'DEPT';</p><p style="line-height: 1.5; margin: 10px auto;">已选择10行。</p><p style="line-height: 1.5; margin: 10px auto;">Execution Plan</p><p style="line-height: 1.5; margin: 10px auto;">----------------------------------------------------------</p><p style="line-height: 1.5; margin: 10px auto;">0 SELECT STATEMENT Optimizer=CHOOSE (Cost=38 Card=14 Bytes=1218)</p><p style="line-height: 1.5; margin: 10px auto;">1 0 TABLE ACCESS (FULL) OF 'T' (Cost=38 Card=14 Bytes=1218)</p><p style="line-height: 1.5; margin: 10px auto;">Statistics</p><p style="line-height: 1.5; margin: 10px auto;">----------------------------------------------------------</p><p style="line-height: 1.5; margin: 10px auto;">0 recursive calls</p><p style="line-height: 1.5; margin: 10px auto;">0 db block gets</p><p style="line-height: 1.5; margin: 10px auto;">375 consistent gets</p><p style="line-height: 1.5; margin: 10px auto;">17 physical reads</p><p style="line-height: 1.5; margin: 10px auto;">0 redo size</p><p style="line-height: 1.5; margin: 10px auto;">1224 bytes sent via SQL*Net to client</p><p style="line-height: 1.5; margin: 10px auto;">503 bytes received via SQL*Net from client</p><p style="line-height: 1.5; margin: 10px auto;">2 SQL*Net roundtrips to/from client</p><p style="line-height: 1.5; margin: 10px auto;">0 sorts (memory)</p><p style="line-height: 1.5; margin: 10px auto;">0 sorts (disk)</p><p style="line-height: 1.5; margin: 10px auto;">10 rows processed</p><p style="line-height: 1.5; margin: 10px auto;">&nbsp;&nbsp;&nbsp; 正如我们所料，不使用索引所导致的逻辑读（375）确实比使用索引的逻辑读多（24），达到10倍以上。</p><p style="line-height: 1.5; margin: 10px auto;">继续我们的测试，现在我们来看看Oracle不选择使用索引的情况：</p><p style="line-height: 1.5; margin: 10px auto;"><br>&nbsp;&nbsp;&nbsp; 测试4）</p><p style="line-height: 1.5; margin: 10px auto;">SQL&gt; select * from t where object_name LIKE 'DE%';</p><p style="line-height: 1.5; margin: 10px auto;">已选择180行。</p><p style="line-height: 1.5; margin: 10px auto;">Execution Plan</p><p style="line-height: 1.5; margin: 10px auto;">----------------------------------------------------------</p><p style="line-height: 1.5; margin: 10px auto;">0 SELECT STATEMENT Optimizer=CHOOSE (Cost=38 Card=37 Bytes=3219)</p><p style="line-height: 1.5; margin: 10px auto;">1 0 TABLE ACCESS (FULL) OF 'T' (Cost=38 Card=37 Bytes=3219)</p><p style="line-height: 1.5; margin: 10px auto;">Statistics</p><p style="line-height: 1.5; margin: 10px auto;">----------------------------------------------------------</p><p style="line-height: 1.5; margin: 10px auto;">0 recursive calls</p><p style="line-height: 1.5; margin: 10px auto;">0 db block gets</p><p style="line-height: 1.5; margin: 10px auto;">386 consistent gets</p><p style="line-height: 1.5; margin: 10px auto;">16 physical reads</p><p style="line-height: 1.5; margin: 10px auto;">0 redo size</p><p style="line-height: 1.5; margin: 10px auto;">12614 bytes sent via SQL*Net to client</p><p style="line-height: 1.5; margin: 10px auto;">624 bytes received via SQL*Net from client</p><p style="line-height: 1.5; margin: 10px auto;">13 SQL*Net roundtrips to/from client</p><p style="line-height: 1.5; margin: 10px auto;">0 sorts (memory)</p><p style="line-height: 1.5; margin: 10px auto;">0 sorts (disk)</p><p style="line-height: 1.5; margin: 10px auto;">180 rows processed</p><p style="line-height: 1.5; margin: 10px auto;">&nbsp;&nbsp;&nbsp; 这次只选择了180条数据，跟表T中总的数据量29489条相比，显然只是很小的一部分，但是Oracle还是选择了全表扫描，有386个逻辑读。这种情况下，如果我们强制使用索引，情况会怎样呢？</p><p style="line-height: 1.5; margin: 10px auto;">SQL&gt; select/**//*+ INDEX(T INDX_T)*/ * from t where object_name LIKE 'DE%';</p><p style="line-height: 1.5; margin: 10px auto;">已选择180行。</p><p style="line-height: 1.5; margin: 10px auto;">Execution Plan</p><p style="line-height: 1.5; margin: 10px auto;">----------------------------------------------------------</p><p style="line-height: 1.5; margin: 10px auto;">0 SELECT STATEMENT Optimizer=CHOOSE (Cost=182 Card=37 Bytes=3219)</p><p style="line-height: 1.5; margin: 10px auto;">1 0 TABLE ACCESS (BY INDEX ROWID) OF 'T' (Cost=182 Card=37 Bytes=3219)</p><p style="line-height: 1.5; margin: 10px auto;">2 1 INDEX (FULL SCAN) OF 'INDX_T' (NON-UNIQUE) (Cost=144 Card=37)</p><p style="line-height: 1.5; margin: 10px auto;">Statistics</p><p style="line-height: 1.5; margin: 10px auto;">----------------------------------------------------------</p><p style="line-height: 1.5; margin: 10px auto;">0 recursive calls</p><p style="line-height: 1.5; margin: 10px auto;">0 db block gets</p><p style="line-height: 1.5; margin: 10px auto;">335 consistent gets</p><p style="line-height: 1.5; margin: 10px auto;">0 physical reads</p><p style="line-height: 1.5; margin: 10px auto;">0 redo size</p><p style="line-height: 1.5; margin: 10px auto;">4479 bytes sent via SQL*Net to client</p><p style="line-height: 1.5; margin: 10px auto;">624 bytes received via SQL*Net from client</p><p style="line-height: 1.5; margin: 10px auto;">13 SQL*Net roundtrips to/from client</p><p style="line-height: 1.5; margin: 10px auto;">0 sorts (memory)</p><p style="line-height: 1.5; margin: 10px auto;">0 sorts (disk)</p><p style="line-height: 1.5; margin: 10px auto;">180 rows processed</p><p style="line-height: 1.5; margin: 10px auto;">&nbsp;&nbsp;&nbsp; 通过添加提示（hint），我们强制Oracle使用了索引扫描（index full scan），执行了335个逻辑读，比使用全表扫描的时候少了一些。</p><p style="line-height: 1.5; margin: 10px auto;">&nbsp;&nbsp;&nbsp; 由此可见，Oracle优化器有时会做出错误的选择，因为它再“聪明”，也不如我们SQL语句编写人员更清楚表中数据的分布，在这种情况下，通过使用提示（hint），我们可以帮助Oracle优化器作出更好的选择。</p><br><div style="color:gray"><small>来源：&nbsp;&lt;<a href="http://www.cnblogs.com/rootq/archive/2008/10/19/1314669.html">http://www.cnblogs.com/rootq/archive/2008/10/19/1314669.html</a><small>&gt;</small></small></div><small><small>&nbsp;</small></small></div></body></html>