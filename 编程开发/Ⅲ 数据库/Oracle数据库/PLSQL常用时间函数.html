<meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>PLSQL常用时间函数</title><?xml version="1.0" encoding="UTF-8"?>


<div style="word-wrap: break-word; -webkit-nbsp-mode: space; -webkit-line-break: after-white-space;"><p><b>PLSQL</b><b>常用时间函数</b></p><p>一，获得时间</p><p>1．Sysdate 当前日期和时间<br/>
SQL&gt; Select sysdate from dual;<br/>
2．Last_day 本月最后一天<br/>
SQL&gt; Select last_day(sysdate) from dual;<br/>
3．Add_months(d,n) 当前日期d后推n个月<br/>
用于从一个日期值增加或减少一些月份<br/>
date_value:=add_months(date_value,number_of_months)<br/>
SQL&gt; Select add_months(sysdate,2) from dual;<br/>
4．Months_between(f,s) 日期f和s间相差月数<br/>
SQL&gt; select months_between(sysdate,to_date(&#39;2005-11-12&#39;,&#39;yyyy-mm-dd&#39;))from dual;<br/>
MONTHS_BETWEEN(SYSDATE,TO_DATE(&#39;2005-11-12&#39;,&#39;YYYY-MM-DD&#39;))<br/>
5．NEXT_DAY(d, day_of_week)<br/>
返回由&quot;day_of_week&quot;命名的，在变量&quot;d&quot;指定的日期之后的第一个工作日的日期。参数&quot;day_of_week&quot;必须为该星期中的某一天。<br/>
SQL&gt; SELECT next_day(to_date(&#39;20050620&#39;,&#39;YYYYMMDD&#39;),1) FROM dual;<br/>
6．current_date()返回当前会话时区中的当前日期<br/>
date_value:=current_date<br/>
SQL&gt; column sessiontimezone for a15<br/>
SQL&gt; select sessiontimezone,current_date from dual;<br/>
SESSIONTIMEZONE CURRENT_DA<br/>
--------------- ----------<br/>
+08:00 13-11月-03<br/>
SQL&gt; alter session set time_zone=&#39;-11:00&#39; 2 /<br/>
会话已更改。<br/>
SQL&gt; select sessiontimezone,current_timestamp from dual;<br/>
SESSIONTIMEZONE CURRENT_TIMESTAMP<br/>
--------------- ------------------------------------<br/>
-11:00 12-11月-03 04.59.13.668000 下午 -11:00<br/>
7。current_timestamp()以timestamp with time zone数据类型返回当前会话时区中的当前日期<br/>
SQL&gt; select current_timestamp from dual;<br/>
CURRENT_TIMESTAMP<br/>
---------------------------------------------------------------------------<br/>
21-6月 -05 10.13.08.220589 上午 +08:00<br/>
8。dbtimezone返回时区<br/>
SQL&gt; select dbtimezone from dual;<br/>
DBTIME<br/>
------<br/>
-08:00<br/>
9。extract()找出日期或间隔值的字段值<br/>
date_value:=extract(date_field from [datetime_value|interval_value])<br/>
SQL&gt; select extract(month from sysdate) &quot;This Month&quot; from dual;<br/>
This Month<br/>
----------<br/>
6<br/>
SQL&gt; select extract(year from add_months(sysdate,36)) &quot; Years&quot; from dual;<br/>
Years<br/>
----------<br/>
2008<br/>
10。localtimestamp()返回会话中的日期和时间<br/>
SQL&gt; select localtimestamp from dual;<br/>
LOCALTIMESTAMP<br/>
---------------------------------------------------------------------------<br/>
21-6月 -05 10.18.15.855652 上午<br/>
常用日期数据格式（该段为摘抄）<br/>
Y或YY或YYY 年的最后一位，两位或三位 Select to_char(sysdate,’YYY’) from dual； 002表示2002年<br/>
SYEAR或YEAR SYEAR使公元前的年份前加一负号 Select to_char(sysdate,’SYEAR’) from dual； -1112表示公元前111 2年<br/>
Q 季度，1～3月为第一季度 Select to_char(sysdate,’Q’) from dual； 2表示第二季度①<br/>
MM 月份数 Select to_char(sysdate,’MM’) from dual； 12表示12月<br/>
RM 月份的罗马表示 Select to_char(sysdate,’RM’) from dual； IV表示4月<br/>
Month 用9个字符长度表示的月份名 Select to_char(sysdate,’Month’) from dual； May后跟6个空格表示5月<br/>
WW 当年第几周 Select to_char(sysdate,’WW’) from dual； 24表示2002年6月13日为第24周<br/>
W 本月第几周 Select to_char(sysdate,’W’) from dual； 2002年10月1日为第1周<br/>
DDD 当年第几, 1月1日为001，2月1日为032 Select to_char(sysdate,’DDD’) from dual； 363 2002年1 2月2 9日为第363天<br/>
DD 当月第几天 Select to_char(sysdate,’DD’) from dual； 04 10月4日为第4天<br/>
D 周内第几天 Select to_char(sysdate,’D’) from dual； 5 2002年3月14日为星期一<br/>
DY 周内第几天缩写 Select to_char(sysdate,’DY’) from dual； SUN 2002年3月24日为星期天<br/>
HH或HH12 12进制小时数 Select to_char(sysdate,’HH’) from dual； 02 午夜2点过8分为02<br/>
HH24 24小时制 Select to_char(sysdate,’HH24’) from dual； 14 下午2点08分为14<br/>
MI 分钟数(0～59) Select to_char(sysdate,’MI’) from dual； 17下午4点17分<br/>
SS 秒数(0～59) Select to_char(sysdate,’SS’) from dual； 22 11点3分22秒<br/>
提示注意不要将MM格式用于分钟(分钟应该使用MI)。MM是用于月份的格式，将它用于分钟也能工作，但结果是错误的。<br/>
现在给出一些实践后的用法：<br/>
1。上月末天：<br/>
SQL&gt; select to_char(add_months(last_day(sysdate),-1),&#39;yyyy-MM-dd&#39;) LastDay from dual;<br/>
LASTDAY<br/>
----------<br/>
2005-05-31<br/>
2。上月今天<br/>
SQL&gt; select to_char(add_months(sysdate,-1),&#39;yyyy-MM-dd&#39;) PreToday from dual;<br/>
PRETODAY<br/>
----------<br/>
2005-05-21<br/>
3.上月首天<br/>
SQL&gt; select to_char(add_months(last_day(sysdate)+1,-2),&#39;yyyy-MM-dd&#39;) firstDay from dual;<br/>
FIRSTDAY<br/>
----------<br/>
2005-05-01<br/>
4.按照每周进行统计<br/>
SQL&gt; select to_char(sysdate,&#39;ww&#39;) from dual group by to_char(sysdate,&#39;ww&#39;);<br/>
TO<br/>
--<br/>
25<br/>
5。按照每月进行统计<br/>
SQL&gt; select to_char(sysdate,&#39;mm&#39;) from dual group by to_char(sysdate,&#39;mm&#39;);<br/>
TO<br/>
--<br/>
06<br/>
6。按照每季度进行统计<br/>
SQL&gt; select to_char(sysdate,&#39;q&#39;) from dual group by to_char(sysdate,&#39;q&#39;);<br/>
T<br/>
-<br/>
2<br/>
7。按照每年进行统计<br/>
SQL&gt; select to_char(sysdate,&#39;yyyy&#39;) from dual group by to_char(sysdate,&#39;yyyy&#39;);<br/>
TO_C<br/>
----<br/>
2005<br/>
8.要找到某月中所有周五的具体日期<br/>
select to_char(t.d,&#39;YY-MM-DD&#39;) from (<br/>
select trunc(sysdate, &#39;MM&#39;)+rownum-1 as d<br/>
from dba_objects<br/>
where rownum &lt; 32) t<br/>
where to_char(t.d, &#39;MM&#39;) = to_char(sysdate, &#39;MM&#39;) --找出当前月份的周五的日期<br/>
and trim(to_char(t.d, &#39;Day&#39;)) = &#39;星期五&#39;<br/>
--------<br/>
03-05-02<br/>
03-05-09<br/>
03-05-16<br/>
03-05-23<br/>
03-05-30<br/>
如果把where to_char(t.d, &#39;MM&#39;) = to_char(sysdate, &#39;MM&#39;)改成sysdate-90，即为查找当前月份的前三个月中的每周五的日期。<br/>
9.oracle中时间运算<br/>
内容如下：<br/>
1、oracle支持对日期进行运算<br/>
2、日期运算时是以天为单位进行的<br/>
3、当需要以分秒等更小的单位算值时，按时间进制进行转换即可<br/>
4、进行时间进制转换时注意加括号，否则会出问题<br/>
SQL&gt; alter session set nls_date_format=&#39;yyyy-mm-dd hh:mi:ss&#39;;<br/>
会话已更改。<br/>
SQL&gt; set serverout on<br/>
SQL&gt; declare<br/>
2 DateValue date;<br/>
3 begin<br/>
4 select sysdate into DateValue from dual;<br/>
5 dbms_output.put_line(&#39;源时间:&#39;||to_char(DateValue));<br/>
6 dbms_output.put_line(&#39;源时间减1天:&#39;||to_char(DateValue-1));<br/>
7 dbms_output.put_line(&#39;源时间减1天1小时:&#39;||to_char(DateValue-1-1/24));<br/>
8 dbms_output.put_line(&#39;源时间减1天1小时1分:&#39;||to_char(DateValue-1-1/24-1/(24*60)));<br/>
9 dbms_output.put_line(&#39;源时间减1天1小时1分1秒:&#39;||to_char(DateValue-1-1/24-1/(24*60)-1/(24*60*60)));<br/>
10 end;<br/>
11 /<br/>
源时间:2003-12-29 11:53:41<br/>
源时间减1天:2003-12-28 11:53:41<br/>
源时间减1天1小时:2003-12-28 10:53:41<br/>
源时间减1天1小时1分:2003-12-28 10:52:41<br/>
源时间减1天1小时1分1秒:2003-12-28 10:52:40<br/>
PL/SQL 过程已成功完成。<br/>
在Oracle中实现时间相加处理<br/>
-- 名称：Add_Times<br/>
-- 功能：返回d1与NewTime相加以后的结果，实现时间的相加<br/>
-- 说明：对于NewTime中的日期不予考虑<br/>
-- 日期：2004-12-07<br/>
-- 版本：1.0<br/>
-- 作者：Kevin<br/>
create or replace function Add_Times(d1 in date,NewTime in date) return date<br/>
is<br/>
hh number;<br/>
mm number;<br/>
ss number;<br/>
hours number;<br/>
dResult date;<br/>
begin<br/>
-- 下面依次取出时、分、秒<br/>
select to_number(to_char(NewTime,&#39;HH24&#39;)) into hh from dual;<br/>
select to_number(to_char(NewTime,&#39;MI&#39;)) into mm from dual;<br/>
select to_number(to_char(NewTime,&#39;SS&#39;)) into ss from dual;<br/>
-- 换算出NewTime中小时总和，在一天的百分几<br/>
hours := (hh + (mm / 60) + (ss / 3600))/ 24;<br/>
-- 得出时间相加后的结果<br/>
select d1 + hours into dResult from dual;<br/>
return(dResult);<br/>
end Add_Times;<br/>
-- 测试用例<br/>
-- select Add_Times(sysdate,to_date(&#39;2004-12-06 03:23:00&#39;,&#39;YYYY-MM-DD HH24:MI:SS&#39;)) from dual<br/>
在Oracle9i中计算时间差<br/>
计算时间差是Oracle DATA数据类型的一个常见问题。Oracle支持日期计算，你可以创建诸如“日期1－日期2”这样的表达式来计算这两个日期之间的时间差。<br/>
一旦你发现了时间差异，你可以使用简单的技巧来以天、小时、分钟或者秒为单位来计算时间差。为了得到数据差，你必须选择合适的时间度量单位，这样就可以进行数据格式隐藏。<br/>
使用完善复杂的转换函数来转换日期是一个诱惑，但是你会发现这不是最好的解决方法。<br/>
round(to_number(end-date-start_date))- 消逝的时间（以天为单位）<br/>
round(to_number(end-date-start_date)*24)- 消逝的时间（以小时为单位）<br/>
round(to_number(end-date-start_date)*1440)- 消逝的时间（以分钟为单位）<br/>
显示时间差的默认模式是什么？为了找到这个问题的答案，让我们进行一个简单的SQL *Plus查询。<br/>
SQL&gt; select sysdate-(sysdate-3) from dual;<br/>
SYSDATE-(SYSDATE-3)<br/>
-------------------<br/>
3<br/>
这里，我们看到了Oracle使用天来作为消逝时间的单位，所以我们可以很容易的使用转换函数来把它转换成小时或者分钟。然而，当分钟数不是一个整数时，我们就会遇到放置小数点的问题。<br/>
Select<br/>
(sysdate-(sysdate-3.111))*1440<br/>
from<br/>
dual;<br/>
(SYSDATE-(SYSDATE-3.111))*1440<br/>
------------------------------<br/>
4479.83333<br/>
当然，我们可以用ROUND函数（即取整函数）来解决这个问题，但是要记住我们必须首先把DATE数据类型转换成NUMBER数据类型。<br/>
Select<br/>
round(to_number(sysdate-(sysdate-3.111))*1440)<br/>
from<br/>
dual;<br/>
ROUND(TO_NUMBER(SYSDATE-(SYSDATE-3.111))*1440)<br/>
----------------------------------------------<br/>
4480<br/>
我们可以用这些函数把一个消逝时间近似转换成分钟并把这个值写入Oracle表格中。在这个例子里，我们有一个离线（logoff）系统级触发机制来计算已经开始的会话时间并把它放入一个Oracle STATSPACK USER_LOG扩展表格之中。<br/>
Update<br/>
perfstat.stats$user_log<br/>
set<br/>
elapsed_minutes =<br/>
round(to_number(logoff_time-logon_time)*1440)<br/>
where<br/>
user = user_id<br/>
and<br/>
elapsed_minutes is NULL;<br/>
查出任一年月所含的工作日<br/>
CREATE OR REPLACE FUNCTION Get_WorkingDays(<br/>
ny IN VARCHAR2<br/>
) RETURN INTEGER IS<br/><br/>
Result INTEGER;<br/>
BEGIN<br/>
SELECT COUNT(*) INTO Result<br/>
FROM (SELECT MOD(MOD(q.rq-to_date(&#39;2001-12-30&#39;,&#39;yyyy-mm-dd&#39;),7),7) weekday<br/>
FROM ( SELECT to_date(ny||t.dd,&#39;yyyymmdd&#39;) rq<br/>
FROM (SELECT substr(100+ROWNUM,2,2) dd<br/>
FROM ljrq z WHERE Rownum&lt;=31<br/>
) t<br/>
WHERE to_date(ny||t.dd,&#39;yyyymmdd&#39;)<br/>
BETWEEN to_date(ny,&#39;yyyymm&#39;)<br/>
AND last_day(to_date(ny,&#39;yyyymm&#39;))<br/>
)q<br/>
) a<br/>
WHERE a.weekday NOT IN(0,6);<br/>
RETURN Result;<br/>
END Get_WorkingDays;<br/>
______________________________________<br/>
还有一个版本<br/>
CREATE OR REPLACE FUNCTION Get_WorkingDays(<br/>
ny IN VARCHAR2<br/>
) RETURN INTEGER IS<br/><br/>
Result INTEGER := 0;<br/>
myts INTEGER; --所给年月的天数<br/>
scts INTEGER; --某天距2001-12-30所差的天数<br/>
rq DATE;<br/>
djt INTEGER := 1; --<br/>
BEGIN<br/>
myts := to_char(last_day(to_date(ny,&#39;yyyymm&#39;)),&#39;dd&#39;);<br/>
LOOP<br/>
rq := TO_date(ny||substr(100+djt,2),&#39;yyyymmdd&#39;);<br/>
scts := rq - to_date(&#39;2001-12-30&#39;,&#39;yyyy-mm-dd&#39;);<br/>
IF MOD(MOD(scts,7)+7,7) NOT IN(0,6) THEN<br/>
Result := Result + 1;<br/>
END IF;<br/>
djt := djt + 1;<br/>
EXIT WHEN djt&gt;myts;<br/>
END LOOP;<br/>
RETURN Result;<br/>
END Get_WorkingDays;<br/>
以上两个版本的比较<br/>
第一个版本一条SQL语句就可以得出结果，不需要编程就可以达到目的。但需要使用任意一张有权访问的、记录条数至少为31的一张表或视图。<br/>
第二个版本需要编程，但不需要表或者视图。<br/>
这两个版本都还存在需要完善的地方，即没有考虑节日，如五一、十一、元旦、春节这些节假期都没有去除。这些节假日应该维护成一张表，然后通过查表来去除这些节假日。　</p></div>