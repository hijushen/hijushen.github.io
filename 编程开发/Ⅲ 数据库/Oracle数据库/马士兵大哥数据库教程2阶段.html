<meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>马士兵大哥数据库教程2阶段</title><?xml version="1.0" encoding="UTF-8"?>


<div style="word-wrap: break-word; -webkit-nbsp-mode: space; -webkit-line-break: after-white-space;"><b>user_indexes;user_tables;user_views;用户字典表dictionary</b><div><b>select user_tables user_views;user_indexes&nbsp;</b></div><div>视图view；create view v$_stu as select ,,, from .</div><div>建立视图要付出维护上的代价。</div><div>序列sequence，Oracle独有的东西；</div><div>create sequence seq；SELECT SEQ.NEXTVAL FORM DUAL;</div><div>数据库三范式：只是一种规范，该打破就打破。cilver Bullet 银弹，没有完美的解决方案。</div><div>第一范式：1，要有主键；2，列不可分。减少数据冗余。</div><div>第二范式：多对多表关系设定：1，不存在部分依赖；如果有多个主键，之间不能有依赖关系。即其他信息不能 部分依赖主键。</div><div>第三范式：不存在传递函数依赖。即每个非关键字都独立于其他非关键字列，并依赖于关键字。</div><div><font color="#BA00FF"><b>PL/SQL的Oracle内部编程语言</b></font></div><div><font color="#BA00FF"><b>T-SQL是SQ-Server 的编程语言</b></font></div><div><b>例如存储过程：</b></div><div>最简单的存储过程：begin dbms_output.put_line(&#39;HelloWorld!&#39;);end;</div><div>启动：set serveroutput on; &nbsp;再执行一次上面，就会有输出。</div><div>Oracle常见7中数据类型：</div><div>1，binary_integer:整数，主要用来计数，而不是表示字段类型；例如数组下标哦。</div><div>2，number 数字类型；</div><div>3，char 定长字符串；</div><div>4，varchar 变长字符串；</div><div>5，date 日期；</div><div>6，long 长字符串，最长2GB；</div><div>7，boolean布尔类型；可以取true，false，和NULL值。</div><div>declare v_empno number(4);</div><div>&nbsp; &nbsp; &nbsp; &nbsp; v_empno v_empno%type;<br/></div><div>复杂数据类型：</div><div>1，--table数据类型：//数组</div><div>declare</div><div>&nbsp; &nbsp; &nbsp;type <font color="#FF0000" style="font-size: 16px;"><b><u>type_table_emp_empno</u></b></font> is table of emp.empno%type index by binary_integer;</div><div>&nbsp; &nbsp; &nbsp;v_empnos type_table_emp_empno</div><div>begin&nbsp;</div><div>&nbsp; &nbsp; &nbsp;v_empnos(0) ：= 7369；</div><div>&nbsp; &nbsp; &nbsp;v_empnos(2) := 7839;</div><div>&nbsp; &nbsp; &nbsp;v_empnos(-1) := 9999; /* 可存在负数的下标 */</div><div>&nbsp; &nbsp; &nbsp;dbms_output.put_line(v_empnos(-1));</div><div>&nbsp; &nbsp; &nbsp;end;</div><div>2，--Record数据类型；//集合、类的概念&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</div><div>declare</div><div>&nbsp; &nbsp; &nbsp;type type_record_dept is record</div><div>&nbsp; &nbsp; &nbsp;(</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; deptno dept.deptno%type,</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dname dept.dname%type,</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; loc dept.loc%type</div><div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;);</div><div>&nbsp; &nbsp; &nbsp;v_temp type_record_dept;</div><div>3，--使用%rowtype声明record对象</div><div>&nbsp;declare</div><div>&nbsp; &nbsp; &nbsp;v_temp dept%rowtype;//可以直接根据表结构来动态定义。</div><div><br/></div><div>PL/SQL中的SQL语句：</div><div>1，有且只有一条输出记录；</div><div>2，例子：select ename,sal into v_ename,v_sal from emp where depno = &#39;&#39;;//sql需要配合into使用。</div><div>3，<font color="#2D4FC9">Update动作需要commit。</font></div><div>4,dbms_output_put_line(<font color="#9C004C">sql</font>%rowcount || &#39;条记录被影响&#39;)//<font color="#FF4635">sql</font>为关键字，代表刚才执行的sql语句；</div><div><br/></div><div>PL/SQL中的DDL语句：</div><div>begin&nbsp;</div><div>&nbsp; &nbsp; &nbsp;<font color="#D100FF">execute immediate</font> &#39;create table T (nnn varchar2(20) default &#39;&#39;aaa&#39;&#39;)&#39; //2个单引号代表一个单引号，需要加上粉红部分；</div><div>end;/</div><div><br/></div><div>PL/SQL分支和循环</div><div>分支：if then ; elsif then ;else ; end if;end;</div><div>循环：1) loop ; 累加；exit when 条件; end loop;end;</div><div>&nbsp; &nbsp; &nbsp; 2) while 条件; loop ;累加;end loop;end;</div><div>&nbsp; &nbsp; &nbsp; 3) for k in 1..10 loop ;end loop; end;//</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;for k in reverse 1..10 loop ;end loop;end; --完成了逆序输出循环。其中1..10代表1到10，增强的for循环。</div><div><br/></div><div>错误处理：</div><div>exception</div><div>&nbsp; &nbsp; &nbsp;when 错误1 then &nbsp; &nbsp; &nbsp;;</div><div>&nbsp; &nbsp; &nbsp;when others then &nbsp; &nbsp; &nbsp;; &nbsp; &nbsp; 常见的2种：too_many_rows &nbsp; &nbsp; no_data_found &nbsp;<a>//查手册</a></div><div><br/></div><div>完整的例子：</div><div>--创建一个errorlog表：</div><div>&nbsp; &nbsp; &nbsp;create table errorlog</div><div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(</div><div>&nbsp; &nbsp; &nbsp;id number primary key,</div><div>&nbsp; &nbsp; &nbsp;errcode number,</div><div>&nbsp; &nbsp; &nbsp;errmsg varchar2(1024),</div><div>&nbsp; &nbsp; &nbsp;errdate date</div><div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;);</div><div>&nbsp; &nbsp; &nbsp;create sequence seq_errorlog_id start with 1 increment by 1;</div><div>&nbsp; &nbsp; &nbsp;declare</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; v_depno dept.depno%type := 10;</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; v_errcode number;</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; v_errmsg varchar2(1024);</div><div>&nbsp; &nbsp; &nbsp;begin</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; delete from dept where depno = v_deptno;</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;commit;</div><div>&nbsp; &nbsp; &nbsp;exception</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; when others then</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;roolback;</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; v_errcode :=SQLCODE; --SQLCODE为数据库关键字，代表出错代码</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; v_errmsg := SQLERRM; --SQLERRM为数据库关键字，代表出错信息</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; insert_into errorlog values (seq_errorlog_id.nextval,v_errcode,v_errmsg,sysdate);</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;commit;</div><div>&nbsp; &nbsp; &nbsp;end;</div><div><br/></div><div><br/></div><div><br/></div><div>&nbsp; &nbsp; &nbsp;</div><div><br/></div><div><br/></div></div>