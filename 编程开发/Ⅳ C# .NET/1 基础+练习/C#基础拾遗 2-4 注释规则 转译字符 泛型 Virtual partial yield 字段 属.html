<!DOCTYPE HTML><html><head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"><style id="wiz_custom_css">        html, body {            font-size: 15px;        }        body {            font-family: Helvetica, 'Hiragino Sans GB', '微软雅黑', 'Microsoft YaHei UI', SimSun, SimHei, arial, sans-serif;            line-height: 1.6;            margin: 0;            padding: 20px 36px;            padding: 1.33rem 2.4rem;        }        h1, h2, h3, h4, h5, h6 {            margin: 20px 0 10px;            margin: 1.33rem 0 0.667rem;            padding: 0;            font-weight: bold;        }        h1 {            font-size: 21px;            font-size: 1.4rem;        }        h2 {            font-size: 20px;            font-size: 1.33rem;        }        h3 {            font-size: 18px;            font-size: 1.2rem;        }        h4 {            font-size: 17px;            font-size: 1.13rem;        }        h5 {            font-size: 15px;            font-size: 1rem;        }        h6 {            font-size: 15px;            font-size: 1rem;            color: #777777;            margin: 1rem 0;        }        div, p, ul, ol, dl, li {            margin: 0;        }        blockquote, table, pre, code {            margin: 8px 0;        }        ul, ol {            padding-left: 32px;            padding-left: 2.13rem;        }        blockquote {            padding: 0 12px;            padding: 0 0.8rem;        }        blockquote > :first-child {            margin-top: 0;        }        blockquote > :last-child {            margin-bottom: 0;        }        img {            border: 0;            max-width: 100%;            height: auto !important;            margin: 2px 0;        }        table {            border-collapse: collapse;            border: 1px solid #bbbbbb;        }        td {            padding: 4px 8px;            border-collapse: collapse;            border: 1px solid #bbbbbb;        }        @media screen and (max-width: 660px) {            body {                padding: 20px 18px;                padding: 1.33rem 1.2rem;            }        }        @media only screen and (-webkit-max-device-width: 1024px), only screen and (-o-max-device-width: 1024px), only screen and (max-device-width: 1024px), only screen and (-webkit-min-device-pixel-ratio: 3), only screen and (-o-min-device-pixel-ratio: 3), only screen and (min-device-pixel-ratio: 3) {            html, body {                font-size: 17px;            }            body {                line-height: 1.7;                padding: 0.75rem 0.9375rem;                color: #353c47;            }            h1 {                font-size: 2.125rem;            }            h2 {                font-size: 1.875rem;            }            h3 {                font-size: 1.625rem;            }            h4 {                font-size: 1.375rem;            }            h5 {                font-size: 1.125rem;            }            h6 {                color: inherit;            }            ul, ol {                padding-left: 2.5rem;            }            blockquote {                padding: 0 0.9375rem;            }        }</style>

<style type="text/css" id="wiz_todo_style_id" wiz_link_version="01.00.09">.wiz-todo, .wiz-todo-img {width: 16px; height: 16px; cursor: default; padding: 0 10px 0 2px; vertical-align: -10%;-webkit-user-select: none;} .wiz-todo-label { display: inline-block; padding-top: 7px; padding-bottom: 6px; line-height: 1.5;} .wiz-todo-label-checked {  color: #666;} .wiz-todo-label-unchecked {text-decoration: initial;} .wiz-todo-completed-info {padding-left: 44px; display: inline-block; } .wiz-todo-avatar { width:20px; height: 20px; vertical-align: -20%; margin-right:10px; border-radius: 2px;} .wiz-todo-account, .wiz-todo-dt { color: #666; }</style></head><body  style=""><h2>C#注释 C#转译字符 (2012/12/10 22:09:29)</h2><meta http-equiv="X-UA-Compatible" content="IE=8"><title>C#基础拾遗 2-4 注释规则 转译字符 泛型 Virtual partial yield 字段 属性 访问修饰符</title><!--?xml version="1.0" encoding="UTF-8"?--><div style="word-wrap: break-word; -webkit-nbsp-mode: space; -webkit-line-break: after-white-space;">
C#中///可以<font color="#D100FF">生成注释，同时生成注释文档</font>，summary 摘要，实例：
<div><a>///&lt;summary&gt;</a></div><div><a>///定义一个program类</a></div><div><a>///&lt;/summary&gt;</a></div><div>class program</div><div>{</div><div>&nbsp; &nbsp; &nbsp;///&lt;summary&gt;</div><div>&nbsp; &nbsp; &nbsp;<a>///程序入口方法</a></div><div>&nbsp; &nbsp; &nbsp;<a>///&lt;/summary&gt;</a></div><div>&nbsp; &nbsp; &nbsp;<a>///&lt;param</a>&nbsp;name ="args"&gt; 用于向方法传递多个参数 &lt;/param&gt;</div><div>&nbsp; &nbsp; &nbsp;<a>///&lt;returns&gt;方法返回整形数值&lt;/returns&gt;</a></div><div>&nbsp; &nbsp; &nbsp;static int Main(string[] args)</div><div>&nbsp; &nbsp; &nbsp;{</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return 0;</div><div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</div><div>}</div><div>C# 关于<font color="#E500FF">转译字符</font>处理</div><div>2种方法@""或者是\\表示斜杠；\' \" \\ \0 \r 分别表示显示单引号、双引号、斜杠、空、回车；</div><div><br></div><div><br></div><div><br></div></div><hr><h2>基础拾遗 4 Virtual (2012/11/1 17:36:50)</h2><div style="word-wrap: break-word; -webkit-nbsp-mode: space; -webkit-line-break: after-white-space;"><div>virtual 关键字用于修饰方法、属性、索引器或事件声明，并使它们可以在派生类中被重写。 例如，此方法可被任何继承它的类重写。<div><br><div><br></div></div></div></div><hr><h2>基础拾遗 3 (2012/10/31 15:59:34)</h2><meta http-equiv="X-UA-Compatible" content="IE=8"><title>基础拾遗 3</title><!--?xml version="1.0" encoding="UTF-8"?--><div style="word-wrap: break-word; -webkit-nbsp-mode: space; -webkit-line-break: after-white-space;"><p align="left">上下文关键字用于提供代码中的特定含义，但它不是 C# 中的保留字。</p><p align="left"><b>get</b><b>、</b><b>set</b><b>、</b><b>value</b></p><p align="left"><i>get</i> 在属性或索引器中定义“访问器”方法，以检索该属性或该索引器元素的值。</p><p align="left"><i>set</i> 义属性或索引器中的“访问器”方法，用于设置属性或索引器元素的值。</p><p align="left"><i>value</i> 隐式参数，用于设置访问器以及添加或移除事件处理程序。</p><p align="left">//&nbsp;简单示例<br>
class&nbsp;Employee<br>
{<br>
&nbsp;&nbsp;&nbsp;&nbsp;private&nbsp;string<font color="#EB0073">&nbsp;_name</font>;<br>
&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;string&nbsp;Name<br>
&nbsp;&nbsp;&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;get&nbsp;{&nbsp;return&nbsp;this.<font color="#FF4635">_name</font>;&nbsp;&nbsp;}<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;set&nbsp;{&nbsp;this.<font color="#EB0073">_name</font>&nbsp;=&nbsp;value;&nbsp;}<br>
&nbsp;&nbsp;&nbsp;&nbsp;}<br>
}</p><p align="left"><u>注意</u>：</p><p align="left">&nbsp;&nbsp;&nbsp; get、set“访问器”，在默认情况下具有相同的访问级别。但是有时鉴于对读写的考虑，通常可以限制set的访问级别。对属性或索引器使用访问修饰符受以下条件的制约：</p><p align="left">1.不能对接口或显式接口成员实现使用访问器修饰符。</p><p align="left">2.仅当属性或索引器同时具有 set 和 get 访问器时，才能使用访问器修饰符。这种情况下，只允许对其中一个访问器使用修饰符。</p><p align="left">3.如果属性或索引器具有 override 修饰符，则访问器修饰符必须与重写的访问器的访问器（如果有的话）匹配。</p><p align="left">4.访问器的可访问性级别必须比属性或索引器本身的可访问性级别具有更严格的限制。</p><div align="center"><hr align="center" noshade="noshade" size="2" width="100%"></div><p align="left"><b>partial</b></p><p align="left"><i>partial</i> 分部类型定义允许将类、结构或接口的定义拆分到多个文件中。</p><p align="left">[modifiers]&nbsp;partial&nbsp;type</p><p align="left">1.&nbsp; modifiers是可选的。可以是abstract、new、override、static、virtual、extern，以及访问修饰符中的一个。</p><p align="left">2.&nbsp; type 可以是类、结构和接口之一。</p><p align="left"><u>示例</u>：</p><p align="left">以下的部分类在编译时，将会合并，包括它的方法、类型特性等等。&nbsp;</p><p align="left">&nbsp;1 namespace Hunts.Keywords</p><p align="left">&nbsp;2 {</p><p align="left">&nbsp;3 &nbsp;&nbsp;&nbsp;&nbsp;[System.Serializable]</p><p align="left">&nbsp;4 &nbsp;&nbsp;&nbsp;&nbsp;partial class Test</p><p align="left">&nbsp;5 &nbsp;&nbsp;&nbsp;&nbsp;{</p><p align="left">&nbsp;6 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;void Test1() { }</p><p align="left">&nbsp;7 &nbsp;&nbsp;&nbsp;&nbsp;}</p><p align="left">&nbsp;8 &nbsp;&nbsp;&nbsp;&nbsp;[Conditional("DEBUG")]</p><p align="left">&nbsp;9 &nbsp;&nbsp;&nbsp;&nbsp;partial class Test</p><p align="left">10 &nbsp;&nbsp;&nbsp;&nbsp;{</p><p align="left">11 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;void Test2() { }</p><p align="left">12 &nbsp;&nbsp;&nbsp;&nbsp;}</p><p align="left">13 }</p><p align="left">类相当于：</p><p align="left">&nbsp;1 namespace Hunts.Keywords</p><p align="left">&nbsp;2 {</p><p align="left">&nbsp;3 &nbsp;&nbsp;&nbsp;&nbsp;[System.Serializable]</p><p align="left">&nbsp;4 &nbsp;&nbsp;&nbsp;&nbsp;[Conditional("DEBUG")]</p><p align="left">&nbsp;5 &nbsp;&nbsp;&nbsp;&nbsp;class Test</p><p align="left">&nbsp;6 &nbsp;&nbsp;&nbsp;&nbsp;{</p><p align="left">&nbsp;7 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;void Test1() { }</p><p align="left">&nbsp;8 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;void Test2() { }</p><p align="left">&nbsp;9 &nbsp;&nbsp;&nbsp;&nbsp;}</p><p align="left">10 }</p><p align="left">关于部分（类、接口、结构）的详细使用，可以参阅MSDN Library中的部分类。</p><div align="center"><hr align="center" noshade="noshade" size="2" width="100%"></div><p align="left"><b>where</b></p><p align="left"><i>where</i>&nbsp;子句用于指定类型约束，这些约束可以作为泛型声明中定义的类型参数的变量。</p><p align="left">1.&nbsp;&nbsp;&nbsp; 之所以使用类型约束是因为如果要检查泛型列表中的某个项以确定它是否有效，或者将它与其他某个项进行比较，则编译器必须在一定程度上保证它需要调用的运算符或方法将受到客户端代码可能指定的任何类型参数的支持。这种保证是通过对泛型类定义应用一个或多个约束获得的。</p><p align="left">// 句法</p><p align="left">public class MyGenericClass&lt;T&gt; where T:something</p><p align="left">1.&nbsp;something可以是：结构、类、new()、&lt;基类名&gt;或&lt;接口名称&gt;。</p><p align="left">2.&nbsp;可以同时具有1中的多个约束，且约束自身也可以是泛型类型。</p><p align="left">3.&nbsp;也可以将约束作用于泛型方法或委托。</p><p align="left">要更深入的了解可以参阅MSDN Library中的“泛型编程”以及“类型参数的约束”这些内容。</p><p align="left"><u>示例</u>：&nbsp;</p><p align="left">&nbsp;</p><p align="left">&nbsp;1 // keywords_where.cs</p><p align="left">&nbsp;2</p><p align="left">&nbsp;3 using System;</p><p align="left">&nbsp;4 using System.Collections;</p><p align="left">&nbsp;5</p><p align="left">&nbsp;6 struct MyStruct</p><p align="left">&nbsp;7 {</p><p align="left">&nbsp;8 &nbsp;&nbsp;&nbsp;&nbsp;//...</p><p align="left">&nbsp;9 }</p><p align="left">10</p><p align="left">11 interface IMyInterface</p><p align="left">12 {</p><p align="left">13 &nbsp;&nbsp;&nbsp;&nbsp;//...</p><p align="left">14 }</p><p align="left">15</p><p align="left">16 class MyGenericClass&lt;T1,T2&gt;</p><p align="left">17 &nbsp;&nbsp;&nbsp;&nbsp;where T1: IEnumerable, IMyInterface</p><p align="left">18 &nbsp;&nbsp;&nbsp;&nbsp;where T2: MyStruct, new()</p><p align="left">19 {</p><p align="left">20 &nbsp;&nbsp;&nbsp;&nbsp;public void MyMethod(T1 t1, T2 t2)</p><p align="left">21 &nbsp;&nbsp;&nbsp;&nbsp;{</p><p align="left">22 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//...</p><p align="left">23 &nbsp;&nbsp;&nbsp;&nbsp;}</p><p align="left">24 }</p><p align="left">&nbsp;</p><div align="center"><hr align="center" noshade="noshade" size="2" width="100%"></div><p align="left"><b>yield</b></p><p align="left"><i>yield</i> 在迭代器块中用于向枚举数对象提供值或发出迭代结束信号。&nbsp;</p><p align="left">// expression 进行计算并以枚举数对象值的形式返回。expression 必须可以隐式转换为迭代器的 yield 类型。</p><p align="left">yield return expression;</p><p align="left">yield break;</p><p align="left"><u>示例</u>：</p><p align="left">&nbsp;1 // keywords_yield.cs</p><p align="left">&nbsp;2 using System;</p><p align="left">&nbsp;3 using System.Collections;</p><p align="left">&nbsp;4</p><p align="left">&nbsp;5 namespace Hunts.Keywords</p><p align="left">&nbsp;6 {</p><p align="left">&nbsp;7 &nbsp;&nbsp;&nbsp;&nbsp;public class Employee</p><p align="left">&nbsp;8 &nbsp;&nbsp;&nbsp;&nbsp;{</p><p align="left">&nbsp;9 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;private string _name;</p><p align="left">10 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;private int _id;</p><p align="left">11</p><p align="left">12 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public string Name</p><p align="left">13 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{</p><p align="left">14 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;get { return this._name; }</p><p align="left">15 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;set { this._name = value; }</p><p align="left">16 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</p><p align="left">17</p><p align="left">18 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public int ID</p><p align="left">19 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{</p><p align="left">20 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;get { return this._id; }</p><p align="left">21 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;set { this._id = value; }</p><p align="left">22 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</p><p align="left">23</p><p align="left">24 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 为给定数组中的人名进行编号</p><p align="left">25 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public static IEnumerable SetIDs(string[] names)</p><p align="left">26 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{</p><p align="left">27 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int counter = 0;</p><p align="left">28 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Employee result = new Employee();</p><p align="left">29 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;while (counter++ &lt; names.Length)</p><p align="left">30 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{</p><p align="left">31 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;result._id = counter;</p><p align="left">32 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;result._name = names[counter - 1];</p><p align="left">33 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="#F14F9A">yield</font> return result;</p><p align="left">34 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</p><p align="left">35 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</p><p align="left">36 &nbsp;&nbsp;&nbsp;&nbsp;}</p><p align="left">37</p><p align="left">38 &nbsp;&nbsp;&nbsp;&nbsp;class EmployeeList</p><p align="left">39 &nbsp;&nbsp;&nbsp;&nbsp;{</p><p align="left">40 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;static void Main()</p><p align="left">41 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{</p><p align="left">42 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;string[] names = { "Jones", "Carl", "Dennis", "Evan", "Hugo", "Ivan" };</p><p align="left">43</p><p align="left">44 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 显示编号操作的结果</p><p align="left">45 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;foreach (Employee e in Employee.SetIDs(names))</p><p align="left">46 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{</p><p align="left">47 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Console.WriteLine("ID:{0} Name:{1}", e.ID,e.Name);</p><p align="left">48 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</p><p align="left">49</p><p align="left">50 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Console.Read();</p><p align="left">51 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</p><p align="left">52 &nbsp;&nbsp;&nbsp;&nbsp;}</p><p align="left">53 }</p><p align="left"><u>注意</u>：</p><p align="left">&nbsp;&nbsp;&nbsp; yield 语句只能出现在 iterator 块中，该块可用作方法、运算符或访问器的体。这类方法、运算符或访问器的体受以下约束的控制：</p><p align="left">1.&nbsp;不允许不安全块。</p><p align="left">2.&nbsp;方法、运算符或访问器的参数不能是 ref 或 out。</p><p align="left">3.&nbsp;yield 语句不能出现在匿名方法中。</p><p align="left">4.&nbsp;当和 expression 一起使用时，yield return 语句不能出现在 catch 块中或含有一个或多个 catch 子句的 try 块中。</p></div><hr><h2>基础拾遗 2 (2012/9/28 16:37:26)</h2><meta http-equiv="X-UA-Compatible" content="IE=8"><title>基础拾遗 2</title><!--?xml version="1.0" encoding="UTF-8"?--><div style="word-wrap: break-word; -webkit-nbsp-mode: space; -webkit-line-break: after-white-space;">
&nbsp;访问修饰符 说明<br>
public 公有访问。不受任何限制。<br>
private 私有访问。<font color="#EB0073">只限于本类成员访问，子类，实例都不能访问</font>。<br>
protected 保护访问。只限于本类和子类访问，实例不能访问。<br>
internal 内部访问。只限于本项目内访问，其他不能访问。<br>
protected internal 内部保护访问。只限于本项目或是子类访问，其他不能访问&nbsp;
</div></body></html>