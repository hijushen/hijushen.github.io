<meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>基础拾遗7 抽象函数重写基类虚方法，密封类，接口，结构与类</title><?xml version="1.0" encoding="UTF-8"?>


<div style="word-wrap: break-word; -webkit-nbsp-mode: space; -webkit-line-break: after-white-space;">
1）可以使用abstract方法重写基类中virtual方法，但是需要使用new显式声明；
<div>Case：<en-media alt="http://images.csdn.net/syntaxhighlighting/OutliningIndicators/None.gif" border="0" hash="274426ce80b7bc826a7c63c158338882" height="16" style="cursor: default;cursor: default;cursor: default;" type="image/png" width="11"/> <font face="Arial" size="2"><span style="font-size:10pt">&nbsp;&nbsp;&nbsp;&nbsp;</span></font></div><blockquote style="margin: 0 0 0 40px; border: none; padding: 0px;"><div>class BaseClass</div><div>{</div><div>public virtual void F()</div><div>&nbsp; {</div><div>&nbsp;&nbsp;&nbsp;&nbsp; Console.WriteLine(&quot;BaseClass.F&quot;);</div><div>&nbsp; }</div><div>}</div><div>abstract class&nbsp; DeriveClass : BaseClass</div><div>{</div><div>public new abstract void F();</div><div>}</div><div><br/></div></blockquote>
2）密封类中继承地虚函数将隐式地转换为非虚函数，密封类本身不再增加新的虚函数；
<div>Case：</div><div>class BaseClass<br/>
{<br/>
public virtual void F()<br/>
{<br/>
Console.WriteLine(&quot;BaseClass.F&quot;);<br/>
}<br/>
}<br/>
sealed class DeriveClass : BaseClass<br/>
{<br/>
//基类中的虚函数F被隐式的转化为非虚函数<br/><br/>
//密封类中不能再声明新的虚函数G<br/>
//public virtual void G()<br/>
//{<br/>
//&nbsp;&nbsp;&nbsp; Console.WriteLine(&quot;DeriveClass.G&quot;);<br/>
//}<br/>
}&nbsp;<br/><br/>
3）接口可以包含方法，属性，索引指示器和事件，但不能包含常量、域、操作符、构造函数和析构函数，而且不能包含任何静态成员；</div><div><br/></div><div>4）类和结构的区别：</div><div>类是引用类型在堆上分配，类的实例进行赋值只是复制了引用，都指向同一段实际对象分配的内存。类有构造和析构函数，类可以继承和被继承；结构是值类型，在栈上分配（虽然栈的访问速度比堆快，但是栈的访资源有限放），结构的赋值将分配产生一个新的对象。结构没有构造函数，但可以添加。结构没有析构函数。结构不可以继承自另一个结构或被继承，但和类一样可以继承自接口。<br/>
常见结构和类的使用范围：PointGeometry（点状几何）中需要使用类，而其成员则使用结构。例如：</div><div>using System;<br/>
using System.Collections.Generic;<br/>
using System.Text;<br/><br/>
namespace Example16<br/>
{<br/>
interface IPoint<br/>
{<br/>
double X<br/>
&nbsp; {<br/>
&nbsp;&nbsp;&nbsp;&nbsp; get;<br/>
&nbsp;&nbsp;&nbsp;&nbsp; set;<br/>
}<br/>
double Y<br/>
&nbsp; {<br/>
&nbsp;&nbsp;&nbsp;&nbsp; get;<br/>
&nbsp;&nbsp;&nbsp;&nbsp; set;<br/>
}<br/>
double Z<br/>
&nbsp; {<br/>
&nbsp;&nbsp;&nbsp;&nbsp; get;<br/>
&nbsp;&nbsp;&nbsp;&nbsp; set;<br/>
}<br/>
}<br/>
//结构也可以从接口继承<br/>
struct Point: IPoint<br/>
{<br/>
private double x, y, z;<br/>
//结构也可以增加构造函数<br/>
public Point(double X, double Y, double Z)<br/>
&nbsp; {<br/>
&nbsp;&nbsp;&nbsp;&nbsp; this.x = X;<br/>
&nbsp;&nbsp;&nbsp;&nbsp; this.y = Y;<br/>
&nbsp;&nbsp;&nbsp;&nbsp; this.z = Z;<br/>
}<br/>
public double X<br/>
&nbsp; {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; get { return x; }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; set { x = value; }<br/>
}<br/>
public double Y<br/>
&nbsp; {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; get { return x; }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; set { x = value; }<br/>
}<br/>
public double Z<br/>
&nbsp; {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; get { return x; }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; set { x = value; }<br/>
}<br/>
}<br/>
//在此简化了点状Geometry的设计，实际产品中还包含Project（坐标变换）等复杂操作<br/>
class PointGeometry<br/>
{<br/>
private Point value;<br/>
&nbsp;<br/>
public PointGeometry(double X, double Y, double Z)<br/>
&nbsp; {<br/>
&nbsp;&nbsp;&nbsp;&nbsp; value = new Point(X, Y, Z);<br/>
}<br/>
public PointGeometry(Point value)<br/>
&nbsp; {<br/>
&nbsp;&nbsp;&nbsp;&nbsp; //结构的赋值将分配新的内存<br/>
&nbsp;&nbsp;&nbsp;&nbsp; this.value = value;<br/>
}<br/>
public double X<br/>
&nbsp; {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; get { return value.X; }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; set { this.value.X = value; }<br/>
}<br/>
public double Y<br/>
&nbsp; {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; get { return value.Y; }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; set { this.value.Y = value; }<br/>
}<br/>
public double Z<br/>
{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; get { return value.Z; }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; set { this.value.Z = value; }<br/>
}<br/>
public static PointGeometry operator +(PointGeometry Left, PointGeometry Rigth)<br/>
&nbsp; {<br/>
&nbsp;&nbsp;&nbsp;&nbsp; return new PointGeometry(Left.X + Rigth.X, Left.Y + Rigth.Y, Left.Z + Rigth.Z);<br/>
}<br/>
public override string ToString()<br/>
&nbsp; {<br/>
&nbsp;&nbsp;&nbsp;&nbsp; return string.Format(&quot;X: {0}, Y: {1}, Z: {2}&quot;, value.X, value.Y, value.Z);<br/>
}<br/>
}<br/>
class Program<br/>
{<br/>
static void Main(string[] args)<br/>
&nbsp; {<br/>
&nbsp;&nbsp;&nbsp;&nbsp; Point tmpPoint = new Point(1, 2, 3);<br/><br/>
&nbsp;&nbsp;&nbsp;&nbsp; PointGeometry tmpPG1 = new PointGeometry(tmpPoint);<br/>
&nbsp;&nbsp;&nbsp;&nbsp; PointGeometry tmpPG2 = new PointGeometry(tmpPoint);<br/>
&nbsp;&nbsp;&nbsp;&nbsp; tmpPG2.X = 4;<br/>
&nbsp;&nbsp;&nbsp;&nbsp; tmpPG2.Y = 5;<br/>
&nbsp;&nbsp;&nbsp;&nbsp; tmpPG2.Z = 6;<br/><br/>
&nbsp;&nbsp;&nbsp;&nbsp; //由于结构是值类型，tmpPG1 和 tmpPG2 的坐标并不一样<br/>
&nbsp;&nbsp;&nbsp;&nbsp; Console.WriteLine(tmpPG1);<br/>
&nbsp;&nbsp;&nbsp;&nbsp; Console.WriteLine(tmpPG2);<br/><br/>
&nbsp;&nbsp;&nbsp;&nbsp; //由于类是引用类型，对tmpPG1坐标修改后影响到了tmpPG3<br/>
&nbsp;&nbsp;&nbsp;&nbsp; PointGeometry tmpPG3 = tmpPG1;<br/>
&nbsp;&nbsp;&nbsp;&nbsp; tmpPG1.X = 7;<br/>
&nbsp;&nbsp;&nbsp;&nbsp; tmpPG1.Y = 8;<br/>
&nbsp;&nbsp;&nbsp;&nbsp; tmpPG1.Z = 9;<br/>
&nbsp;&nbsp;&nbsp;&nbsp; Console.WriteLine(tmpPG1);<br/>
&nbsp;&nbsp;&nbsp;&nbsp; Console.WriteLine(tmpPG3);<br/><br/>
&nbsp;&nbsp;&nbsp;&nbsp; Console.ReadLine();<br/>
}<br/>
}<br/>
}<br/>
结果：<br/>
X: 1, Y: 2, Z: 3<br/>
X: 4, Y: 5, Z: 6<br/>
X: 7, Y: 8, Z: 9<br/>
X: 7, Y: 8, Z: 9&nbsp;<br/><blockquote style="margin: 0 0 0 40px; border: none; padding: 0px;"><div><br/></div><div align="left"><en-media alt="http://images.csdn.net/syntaxhighlighting/OutliningIndicators/None.gif" border="0" hash="274426ce80b7bc826a7c63c158338882" height="16" style="cursor: default;cursor: default;cursor: default;" type="image/png" width="11"/></div></blockquote></div></div>