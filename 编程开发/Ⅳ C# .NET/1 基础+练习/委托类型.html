<meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>委托类型</title><?xml version="1.0" encoding="UTF-8"?>


<div style="word-wrap: break-word; -webkit-nbsp-mode: space; -webkit-line-break: after-white-space;"><div style="font-size: 16px;">1 委托类型</div><div style="font-size: 16px;">&nbsp; &nbsp; &nbsp;引用存储为函数的类型，事件及事件处理。使用Delegate关键字；</div><div style="font-size: 16px;">&nbsp; &nbsp; &nbsp;例子：</div><div style="font-size: 16px;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ProcessDelegate &nbsp;process；</div><div style="font-size: 16px;">Console.WriteLine(&quot;Enter M to Multiply or D to divide:&quot;);</div><div style="font-size: 16px;">input = Console.ReadLine();</div><div style="font-size: 16px;">if (input == &quot;M&quot;)</div><div style="font-size: 16px;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; process = new processDelegate(Multiply);</div><div style="font-size: 16px;">else</div><div style="font-size: 16px;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; process = new processDelegate(Divide);</div><div style="font-size: 16px;">Console.writeLine(&quot;Result{0}&quot;,process(param1,param2));</div><div style="font-size: 16px;">Console.ReadKey();</div><div style="font-size: 16px;">}</div><div style="font-size: 16px;"><br/></div><div style="font-size: 16px;">另外其高于函数的地方是，可以作为参数传递：</div><div style="font-size: 16px;">&nbsp; &nbsp; &nbsp;Static void executeFunction(ProcessDelegate process)</div><div style="font-size: 16px;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {</div><div style="font-size: 16px;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;process(2.2,3.3);</div><div style="font-size: 16px;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }</div><div style="font-size: 16px;"><br/></div><div style="font-size: 16px;">Bulid编译方式，Debug 运行期</div><div style="font-size: 16px;">加调试BreakPoint，输出信息中，如果是变量，需要加{}</div><div style="font-size: 16px;"><br/></div><div style="font-size: 16px;">2&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: rgb(255, 0, 0);">委托的好处，就是当两个类中有一个方法，必须共同实现的时候（例如：该方法需要有另一个类的部分参数或属性才能完成，或者，需要由另一个类协助完成，也或者开发一个通用组件或控件时），我们可以使用委托。</span></div><div style="font-size: 16px;"><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;EventHander 和delegate 都是委托的一种，什么是委托，委托可以简单地理解成，当两个类需要共同地完成一个方法的时候，我们就在该方法体内使用委托。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;如何理解共同完成的一个方法呢？</p><p>&nbsp;&nbsp;&nbsp;&nbsp;先看看下面例子，程序里包括两类：Class1.cs和Program.cs，还有一个参数类TestArg.cs。</p><p>在class1.cs的代码如下：</p><div><ol><li>public&nbsp;class&nbsp;Class1</li><li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;event&nbsp;EventHandler&nbsp;beginConstructors;</li><li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;event&nbsp;EventHandler&lt;testArgs&gt;&nbsp;endConstructors;</li><li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;testArgs&nbsp;a&nbsp;&nbsp;=&nbsp;new&nbsp;testArgs();</li><li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;Class1()</li><li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;Test()</li><li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;a.Test&nbsp;=&nbsp;&quot;this&nbsp;is&nbsp;a&nbsp;test&quot;;</li><li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(beginConstructors&nbsp;!=&nbsp;null)&nbsp;;</li><li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;beginConstructors(this,&nbsp;a);</li><li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Console.WriteLine(&quot;in&nbsp;the&nbsp;Test&quot;);</li><li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(endConstructors!=null)</li><li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;endConstructors(this,&nbsp;a);</li><li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Console.WriteLine(&quot;End&quot;);</li></ol></div><p>&nbsp;&nbsp;&nbsp;&nbsp;这里的Test()方法就是需要两个类共同完成的方法。beginConstructors和endConstructors就是两个委 托，利用这两个委托，Program类可以在他的里面继续丰富这个Test()方法。当然如果beginConstructors和 endConstructors在Program里面没有去订阅的话，那么Test()方法就只有Console.WriteLine(&quot;in the Test&quot;);和Console.WriteLine(&quot;End&quot;);这两个操作了。</p><p>下面我们看看Program的代码：</p><div><ol><li>class&nbsp;Program</li><li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;void&nbsp;Main(string[]&nbsp;args)</li><li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Class1&nbsp;cls&nbsp;=&nbsp;new&nbsp;Class1();</li><li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cls.beginConstructors+=new&nbsp;EventHandler(cls_beginConstructors);&nbsp;&nbsp;</li><li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cls.endConstructors&nbsp;+=&nbsp;new&nbsp;EventHandler&lt;testArgs&gt;(cls_endConstructors);</li><li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cls.Test();</li><li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Console.WriteLine(&quot;----------------------&quot;);</li><li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Console.ReadLine();</li><li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;void&nbsp;cls_beginConstructors(object&nbsp;sender,&nbsp;EventArgs&nbsp;e)</li><li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;testArgs&nbsp;arg&nbsp;=&nbsp;(testArgs)&nbsp;e;</li><li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Console.WriteLine(&quot;&lt;&lt;&lt;event&nbsp;test&nbsp;1&quot;);</li><li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Console.WriteLine(&quot;&lt;&lt;&lt;Class1&nbsp;的参数&nbsp;是&nbsp;{0}&quot;,&nbsp;arg.Test);</li><li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;void&nbsp;cls_endConstructors(object&nbsp;sender,&nbsp;testArgs&nbsp;e)</li><li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Console.WriteLine(&quot;&lt;&lt;&lt;event&nbsp;test&nbsp;2&quot;);</li><li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Console.WriteLine(&quot;&lt;&lt;&lt;Class1&nbsp;的参数&nbsp;是&nbsp;{0}&quot;,&nbsp;e.Test);</li></ol></div><p>下面写出testArgs的代码：</p><div><ol><li>public&nbsp;class&nbsp;testArgs&nbsp;:&nbsp;EventArgs</li><li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;private&nbsp;string&nbsp;test&nbsp;=&nbsp;&quot;&quot;;</li><li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;string&nbsp;Test</li><li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;test;</li><li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;test&nbsp;=&nbsp;value;</li></ol></div><p>这个test方法执行的顺序是这样的</p><p>1.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Test = &quot;this is a test&quot;;</p><p>2.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;static void cls_beginConstructors(object sender, EventArgs e)</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; testArgs arg = (testArgs) e;</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Console.WriteLine(&quot;&lt;&lt;&lt;event test 1&quot;);</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Console.WriteLine(&quot;&lt;&lt;&lt;Class1 的参数 是 {0}&quot;, arg.Test);</p><p>3.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Console.WriteLine(&quot;in the Test&quot;);</p><p>4.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;static void cls_endConstructors(object sender, testArgs e)</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Console.WriteLine(&quot;&lt;&lt;&lt;event test 2&quot;);</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Console.WriteLine(&quot;&lt;&lt;&lt;Class1 的参数 是 {0}&quot;, e.Test);</p><p>5.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Console.WriteLine(&quot;End&quot;);</p><p>其中红色部分为Progem类里提供的实现。</p><p><font color="#FF0000">由上面例子我们可以轻松地了解到了委托的好处，就是当两个类中有一个方法，必须共同实现的时候（例如：该方法需要有另一个类的部分参数或属性才能完成，或者，需要由另一个类协助完成，也或者开发一个通用组件或控件时），我们可以使用委托。</font></p><p>另外，大家会留意到，在Class1类里面，定义委托有两种形式</p><p>1.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; public event EventHandler beginConstructors;</p><p>2.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; public event EventHandler&lt;testArgs&gt; endConstructors;</p><p>究竟有什么不同？</p><p>主要不同在于，当我们订阅这两个事件时使用到的参数不同，</p><p>static void cls_beginConstructors(object sender, EventArgs e)和</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; static void cls_endConstructors(object sender, testArgs e)</p><p>第一个是使用普通的事件参数，第二个使用了自定义的事件参数。</p><p>&nbsp;我的博客全面迁移到：<a href="http://hefujian.com/" target="_blank">http://hefujian.com/</a></p></div><div><br/></div></div>