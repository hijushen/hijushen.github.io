<meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>基于C#的socket编程的TCP 异步实现</title><?xml version="1.0" encoding="UTF-8"?>


<div style="word-wrap: break-word; -webkit-nbsp-mode: space; -webkit-line-break: after-white-space;">
基于C#的socket编程的TCP 异步实现<br/>
一、摘要<br/><br/>
&nbsp; 本篇博文阐述基于TCP通信协议的异步实现。<br/><br/>
二、实验平台<br/><br/>
&nbsp; Visual Studio 2010<br/><br/>
三、异步通信实现原理及常用方法<br/><br/>
3.1&nbsp; 建立连接<br/><br/>
在同步模式中，在服务器上使用Accept方法接入连接请求，而在客户端则使用Connect方法来连接服务器。相对地，在异步模式下，服务器可以使用BeginAccept方法和EndAccept方法来完成连接到客户端的任务，在客户端则通过BeginConnect方法和EndConnect方法来实现与服务器的连接。<br/><br/>
&nbsp; BeginAccept在异步方式下传入的连接尝试，它允许其他动作而不必等待连接建立才继续执行后面程序。在调用BeginAccept之前，必须使用Listen方法来侦听是否有连接请求，BeginAccept的函数原型为：<br/><br/>
BeginAccept(AsyncCallback AsyncCallback, Ojbect state)<br/>
AsyncCallBack：代表回调函数<br/><br/>
state：表示状态信息，必须保证state中包含socket的句柄<br/><br/>
使用BeginAccept的基本流程是：<br/>
(1)创建本地终节点，并新建套接字与本地终节点进行绑定；<br/>
(2)在端口上侦听是否有新的连接请求；<br/>
(3)请求开始接入新的连接，传入Socket的实例或者StateOjbect的实例。<br/><br/>
参考代码：<br/><br/>
//定义IP地址<br/>
IPAddress local = IPAddress.Parse(&quot;127.0,0,1&quot;);<br/>
IPEndPoint iep = new IPEndPoint(local,13000);<br/>
//创建服务器的socket对象<br/>
Socket server = new Socket(AddressFamily.InterNetwork,SocketType.Stream,ProtocolType.Tcp);<br/>
server.Bind(iep);<br/>
server.Listen(20);<br/>
server.BeginAccecpt(new AsyncCallback(Accept),server);<br/>
当BeginAccept()方法调用结束后，一旦新的连接发生，将调用回调函数，而该回调函数必须包括用来结束接入连接操作的EndAccept()方法。<br/><br/>
该方法参数列表为 Socket EndAccept(IAsyncResult iar)<br/><br/>
下面为回调函数的实例：<br/><br/>
void Accept(IAsyncResult iar)<br/>
{<br/>
&nbsp;&nbsp;&nbsp; //还原传入的原始套接字<br/>
&nbsp;&nbsp;&nbsp; Socket MyServer = (Socket)iar.AsyncState;<br/>
&nbsp;&nbsp;&nbsp; //在原始套接字上调用EndAccept方法，返回新的套接字<br/>
&nbsp;&nbsp;&nbsp; Socket service = MyServer.EndAccept(iar);<br/>
}<br/>
至此，服务器端已经准备好了。客户端应通过BeginConnect方法和EndConnect来远程连接主机。在调用BeginConnect方法时必须注册相应的回调函数并且至少传递一个Socket的实例给state参数，以保证EndConnect方法中能使用原始的套接字。下面是一段是BeginConnect的调用：<br/><br/>
Socket socket=new Socket(AddressFamily.InterNetwork,SocketType.Stream,ProtocolType.Tcp)<br/>
IPAddress ip=IPAddress.Parse(&quot;127.0.0.1&quot;);<br/>
IPEndPoint iep=new IPEndPoint(ip,13000);<br/>
socket.BeginConnect(iep, new AsyncCallback(Connect),socket);<br/>
EndConnect是一种阻塞方法，用于完成BeginConnect方法的异步连接诶远程主机的请求。在注册了回调函数后必须接收BeginConnect方法返回的IASynccReuslt作为参数。下面为代码演示：<br/><br/>
void Connect(IAsyncResult iar)<br/>
{<br/>
&nbsp;&nbsp;&nbsp; Socket client=(Socket)iar.AsyncState;<br/>
&nbsp;&nbsp;&nbsp; try<br/>
&nbsp;&nbsp;&nbsp; {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; client.EndConnect(iar);<br/>
&nbsp;&nbsp;&nbsp; }<br/>
&nbsp;&nbsp;&nbsp; catch (Exception e)<br/>
&nbsp;&nbsp;&nbsp; {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Console.WriteLine(e.ToString());<br/>
&nbsp;&nbsp;&nbsp; }<br/>
&nbsp;&nbsp;&nbsp; finally<br/>
&nbsp;&nbsp;&nbsp; {<br/><br/>
&nbsp;&nbsp;&nbsp; }<br/>
}<br/>
除了采用上述方法建立连接之后，也可以采用TcpListener类里面的方法进行连接建立。下面是服务器端对关于TcpListener类使用BeginAccetpTcpClient方法处理一个传入的连接尝试。以下是使用BeginAccetpTcpClient方法和EndAccetpTcpClient方法的代码：<br/><br/>
public static void DoBeginAccept(TcpListener listner)<br/>
{<br/>
&nbsp;&nbsp;&nbsp; //开始从客户端监听连接<br/>
&nbsp;&nbsp;&nbsp; Console.WriteLine(&quot;Waitting for a connection&quot;);<br/>
&nbsp;&nbsp;&nbsp; //接收连接<br/>
&nbsp;&nbsp;&nbsp; //开始准备接入新的连接，一旦有新连接尝试则调用回调函数DoAcceptTcpCliet<br/>
&nbsp;&nbsp;&nbsp; listner.BeginAcceptTcpClient(new AsyncCallback(DoAcceptTcpCliet), listner);<br/>
}<br/><br/>
//处理客户端的连接<br/>
public static void DoAcceptTcpCliet(IAsyncResult iar)<br/>
{<br/>
&nbsp;&nbsp;&nbsp; //还原原始的TcpListner对象<br/>
&nbsp;&nbsp;&nbsp; TcpListener listener = (TcpListener)iar.AsyncState;<br/><br/>
&nbsp;&nbsp;&nbsp; //完成连接的动作，并返回新的TcpClient<br/>
&nbsp;&nbsp;&nbsp; TcpClient client = listener.EndAcceptTcpClient(iar);<br/>
&nbsp;&nbsp;&nbsp; Console.WriteLine(&quot;连接成功&quot;);<br/>
}<br/>
代码的处理逻辑为：<br/>
(1)调用BeginAccetpTcpClient方法开开始连接新的连接，当连接视图发生时，回调函数被调用以完成连接操作；<br/>
(2)上面DoAcceptTcpCliet方法通过AsyncState属性获得由BeginAcceptTcpClient传入的listner实例；<br/>
(3)在得到listener对象后，用它调用EndAcceptTcpClient方法，该方法返回新的包含客户端信息的TcpClient。<br/><br/>
BeginConnect方法和EndConnect方法可用于客户端尝试建立与服务端的连接，这里和第一种方法并无区别。下面看实例：<br/><br/>
public void doBeginConnect(IAsyncResult iar)<br/>
{<br/>
&nbsp;&nbsp;&nbsp; Socket client=(Socket)iar.AsyncState;<br/>
&nbsp;&nbsp;&nbsp; //开始与远程主机进行连接<br/>
&nbsp;&nbsp;&nbsp; client.BeginConnect(serverIP[0],13000,requestCallBack,client);<br/>
&nbsp;&nbsp;&nbsp; Console.WriteLine(&quot;开始与服务器进行连接&quot;);<br/>
}<br/>
private void requestCallBack(IAsyncResult iar)<br/>
{<br/>
&nbsp;&nbsp;&nbsp; try<br/>
&nbsp;&nbsp;&nbsp; {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //还原原始的TcpClient对象<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TcpClient client=(TcpClient)iar.AsyncState;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; client.EndConnect(iar);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Console.WriteLine(&quot;与服务器{0}连接成功&quot;,client.Client.RemoteEndPoint);<br/>
&nbsp;&nbsp;&nbsp; }<br/>
&nbsp;&nbsp;&nbsp; catch(Exception e)<br/>
&nbsp;&nbsp;&nbsp; {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Console.WriteLine(e.ToString());<br/>
&nbsp;&nbsp;&nbsp; }<br/>
&nbsp;&nbsp;&nbsp; finally<br/>
&nbsp;&nbsp;&nbsp; {<br/><br/>
&nbsp;&nbsp;&nbsp; }<br/>
}<br/>
以上是建立连接的两种方法。可根据需要选择使用。<br/><br/>
3.2 发送与接受数据<br/>
在建立了套接字的连接后，就可以服务器端和客户端之间进行数据通信了。异步套接字用BeginSend和EndSend方法来负责数据的发送。注意在调用BeginSend方法前要确保双方都已经建立连接，否则会出异常。下面演示代码：<br/><br/>
private static void Send(Socket handler, String data)<br/>
{<br/>
&nbsp;&nbsp;&nbsp; // Convert the string data to byte data using ASCII encoding.&nbsp;&nbsp;&nbsp;&nbsp;<br/>
&nbsp;&nbsp;&nbsp; byte[] byteData = Encoding.ASCII.GetBytes(data);<br/>
&nbsp;&nbsp;&nbsp; // Begin sending the data to the remote device.&nbsp;&nbsp;&nbsp;&nbsp;<br/>
&nbsp;&nbsp;&nbsp; handler.BeginSend(byteData, 0, byteData.Length, 0, new AsyncCallback(SendCallback), handler);<br/>
}<br/>
private static void SendCallback(IAsyncResult ar)<br/>
{<br/>
&nbsp;&nbsp;&nbsp; try<br/>
&nbsp;&nbsp;&nbsp; {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Retrieve the socket from the state object.&nbsp;&nbsp;&nbsp;&nbsp;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Socket handler = (Socket)ar.AsyncState;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Complete sending the data to the remote device.&nbsp;&nbsp;&nbsp;&nbsp;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int bytesSent = handler.EndSend(ar);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Console.WriteLine(&quot;Sent {0} bytes to client.&quot;, bytesSent);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; handler.Shutdown(SocketShutdown.Both);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; handler.Close();<br/>
&nbsp;&nbsp;&nbsp; }<br/>
&nbsp;&nbsp;&nbsp; catch (Exception e)<br/>
&nbsp;&nbsp;&nbsp; {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Console.WriteLine(e.ToString());<br/>
&nbsp;&nbsp;&nbsp; }<br/>
}<br/>
接收数据是通过BeginReceive和EndReceive方法：<br/><br/>
private static void Receive(Socket client)<br/>
{<br/>
&nbsp;&nbsp;&nbsp; try<br/>
&nbsp;&nbsp;&nbsp; {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Create the state object.&nbsp;&nbsp;&nbsp;&nbsp;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; StateObject state = new StateObject();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; state.workSocket = client;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Begin receiving the data from the remote device.&nbsp;&nbsp;&nbsp;&nbsp;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; client.BeginReceive(state.buffer, 0, StateObject.BufferSize, 0, new AsyncCallback(ReceiveCallback), state);<br/>
&nbsp;&nbsp;&nbsp; }<br/>
&nbsp;&nbsp;&nbsp; catch (Exception e)<br/>
&nbsp;&nbsp;&nbsp; {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Console.WriteLine(e.ToString());<br/>
&nbsp;&nbsp;&nbsp; }<br/>
}<br/>
private static void ReceiveCallback(IAsyncResult ar)<br/>
{<br/>
&nbsp;&nbsp;&nbsp; try<br/>
&nbsp;&nbsp;&nbsp; {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Retrieve the state object and the client socket&nbsp;&nbsp;&nbsp;&nbsp;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // from the asynchronous state object.&nbsp;&nbsp;&nbsp;&nbsp;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; StateObject state = (StateObject)ar.AsyncState;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Socket client = state.workSocket;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Read data from the remote device.&nbsp;&nbsp;&nbsp;&nbsp;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int bytesRead = client.EndReceive(ar);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (bytesRead &gt; 0)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // There might be more data, so store the data received so far.&nbsp;&nbsp;&nbsp;&nbsp;<br/><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; state.sb.Append(Encoding.ASCII.GetString(state.buffer, 0, bytesRead));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Get the rest of the data.&nbsp;&nbsp;&nbsp;&nbsp;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; client.BeginReceive(state.buffer, 0, StateObject.BufferSize, 0, new AsyncCallback(ReceiveCallback), state);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // All the data has arrived; put it in response.&nbsp;&nbsp;&nbsp;&nbsp;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (state.sb.Length &gt; 1)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; response = state.sb.ToString();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Signal that all bytes have been received.&nbsp;&nbsp;&nbsp;&nbsp;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; receiveDone.Set();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br/>
&nbsp;&nbsp;&nbsp; }<br/>
&nbsp;&nbsp;&nbsp; catch (Exception e)<br/>
&nbsp;&nbsp;&nbsp; {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Console.WriteLine(e.ToString());<br/>
&nbsp;&nbsp;&nbsp; }<br/>
}<br/>
上述代码的处理逻辑为：<br/><br/>
(1)首先处理连接的回调函数里得到的通讯套接字client，接着开始接收数据；<br/>
(2)当数据发送到缓冲区中，BeginReceive方法试图从buffer数组中读取长度为buffer.length的数据块，并返回接收到的数据量bytesRead。最后接收并打印数据。<br/><br/>
&nbsp; 除了上述方法外，还可以使用基于NetworkStream相关的异步发送和接收方法，下面是基于NetworkStream相关的异步发送和接收方法的使用介绍。<br/>
NetworkStream使用BeginRead和EndRead方法进行读操作，使用BeginWreite和EndWrete方法进行写操作，下面看实例：<br/><br/>
static void DataHandle(TcpClient client)<br/>
{<br/>
&nbsp; TcpClient tcpClient = client;<br/>
&nbsp; //使用TcpClient的GetStream方法获取网络流<br/>
&nbsp; NetworkStream ns = tcpClient.GetStream();<br/>
&nbsp; //检查网络流是否可读<br/>
&nbsp; if(ns.CanRead)<br/>
&nbsp; {<br/>
&nbsp;&nbsp;&nbsp; //定义缓冲区<br/>
&nbsp;&nbsp;&nbsp; byte[] read = new byte[1024];<br/>
&nbsp;&nbsp;&nbsp; ns.BeginRead(read,0,read.Length,new AsyncCallback(myReadCallBack),ns);&nbsp;<br/>
&nbsp; }<br/>
&nbsp; else<br/>
&nbsp; {<br/>
&nbsp;&nbsp;&nbsp; Console.WriteLine(&quot;无法从网络中读取流数据&quot;);<br/>
&nbsp; }<br/>
}<br/><br/>
public static void myReadCallBack(IAsyncResult iar)<br/>
{<br/>
&nbsp;&nbsp;&nbsp; NetworkStream ns = (NetworkStream)iar.AsyncState;<br/>
&nbsp;&nbsp;&nbsp; byte[] read = new byte[1024];<br/>
&nbsp;&nbsp;&nbsp; String data = &quot;&quot;;<br/>
&nbsp;&nbsp;&nbsp; int recv;<br/><br/>
&nbsp;&nbsp;&nbsp; recv = ns.EndRead(iar);<br/>
&nbsp;&nbsp;&nbsp; data = String.Concat(data, Encoding.ASCII.GetString(read, 0, recv));<br/><br/>
&nbsp;&nbsp;&nbsp; //接收到的消息长度可能大于缓冲区总大小，反复循环直到读完为止<br/>
&nbsp;&nbsp;&nbsp; while (ns.DataAvailable)<br/>
&nbsp;&nbsp;&nbsp; {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ns.BeginRead(read, 0, read.Length, new AsyncCallback(myReadCallBack), ns);<br/>
&nbsp;&nbsp;&nbsp; }<br/>
&nbsp;&nbsp;&nbsp; //打印<br/>
&nbsp;&nbsp;&nbsp; Console.WriteLine(&quot;您收到的信息是&quot; + data);<br/>
}<br/>
3.3 程序阻塞与异步中的同步问题<br/>
.Net里提供了EventWaitHandle类来表示一个线程的同步事件。EventWaitHandle即事件等待句柄，他允许线程通过操作系统互发信号和等待彼此的信号来达到线程同步的目的。这个类有2个子类，分别为AutoRestEevnt(自动重置)和ManualRestEvent(手动重置)。下面是线程同步的几个方法：<br/>
(1)Rset方法：将事件状态设为非终止状态，导致线程阻塞。这里的线程阻塞是指允许其他需要等待的线程进行阻塞即让含WaitOne()方法的线程阻塞；<br/>
(2)Set方法：将事件状态设为终止状态，允许一个或多个等待线程继续。该方法发送一个信号给操作系统，让处于等待的某个线程从阻塞状态转换为继续运行，即WaitOne方法的线程不在阻塞；<br/>
(3)WaitOne方法：阻塞当前线程，直到当前的等待句柄收到信号。此方法将一直使本线程处于阻塞状态直到收到信号为止，即当其他非阻塞进程调用set方法时可以继续执行。<br/><br/>
public static void StartListening()<br/>
{<br/>
&nbsp;&nbsp;&nbsp; // Data buffer for incoming data.&nbsp;&nbsp;&nbsp;&nbsp;<br/>
&nbsp;&nbsp;&nbsp; byte[] bytes = new Byte[1024];<br/>
&nbsp;&nbsp;&nbsp; // Establish the local endpoint for the socket.&nbsp;&nbsp;&nbsp;&nbsp;<br/>
&nbsp;&nbsp;&nbsp; // The DNS name of the computer&nbsp;&nbsp;&nbsp;&nbsp;<br/>
&nbsp;&nbsp;&nbsp; // running the listener is &quot;host.contoso.com&quot;.&nbsp;&nbsp;&nbsp;&nbsp;<br/>
&nbsp;&nbsp;&nbsp; //IPHostEntry ipHostInfo = Dns.Resolve(Dns.GetHostName());<br/>
&nbsp;&nbsp;&nbsp; //IPAddress ipAddress = ipHostInfo.AddressList[0];<br/>
&nbsp;&nbsp;&nbsp; IPAddress ipAddress = IPAddress.Parse(&quot;127.0.0.1&quot;);<br/>
&nbsp;&nbsp;&nbsp; IPEndPoint localEndPoint = new IPEndPoint(ipAddress, 11000);<br/>
&nbsp;&nbsp;&nbsp; // Create a TCP/IP socket.&nbsp;&nbsp;&nbsp;&nbsp;<br/>
&nbsp;&nbsp;&nbsp; Socket listener = new Socket(AddressFamily.InterNetwork,SocketType.Stream, ProtocolType.Tcp);<br/>
&nbsp;&nbsp;&nbsp; // Bind the socket to the local&nbsp;&nbsp;&nbsp;&nbsp;<br/>
&nbsp;&nbsp;&nbsp; //endpoint and listen for incoming connections.&nbsp;&nbsp;&nbsp;&nbsp;<br/>
&nbsp;&nbsp;&nbsp; try<br/>
&nbsp;&nbsp;&nbsp; {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; listener.Bind(localEndPoint);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; listener.Listen(100);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; while (true)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Set the event to nonsignaled state.&nbsp;&nbsp;&nbsp;&nbsp;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; allDone.Reset();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Start an asynchronous socket to listen for connections.&nbsp;&nbsp;&nbsp;&nbsp;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Console.WriteLine(&quot;Waiting for a connection...&quot;);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; listener.BeginAccept(new AsyncCallback(AcceptCallback),listener);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Wait until a connection is made before continuing.&nbsp;&nbsp;&nbsp;&nbsp;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; allDone.WaitOne();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br/>
&nbsp;&nbsp;&nbsp; }<br/>
&nbsp;&nbsp;&nbsp; catch (Exception e)<br/>
&nbsp;&nbsp;&nbsp; {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Console.WriteLine(e.ToString());<br/>
&nbsp;&nbsp;&nbsp; }<br/>
&nbsp;&nbsp;&nbsp; Console.WriteLine(&quot;\nPress ENTER to continue...&quot;);<br/>
&nbsp;&nbsp;&nbsp; Console.Read();<br/>
}<br/>
上述代码的逻辑为：<br/><br/>
(1)试用了ManualRestEvent对象创建一个等待句柄，在调用BeginAccept方法前使用Rest方法允许其他线程阻塞；<br/>
(2)为了防止在连接完成之前对套接字进行读写操作，务必要在BeginAccept方法后调用WaitOne来让线程进入阻塞状态。<br/><br/>
当有连接接入后系统会自动调用会调用回调函数，所以当代码执行到回调函数时说明连接已经成功，并在函数的第一句就调用Set方法让处于等待的线程可以继续执行。<br/><br/>
四、实例<br/><br/>
&nbsp; 下面是一个实例，客户端请求连接，服务器端侦听端口，当连接建立之后，服务器发送字符串给客户端，客户端收到后并回发给服务器端。<br/><br/>
服务器端代码：<br/><br/>
View Code<br/>
客户端代码：<br/><br/>
View Code<br/>
五、实验结果<br/><br/><br/>
图1 服务器端界面<br/><br/><br/>
图2 客户端界面<br/><br/><br/></div>