<!DOCTYPE HTML><html><head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">

<title>准备练习vim, visual studio安装viemu</title>
    <!--mark |wiz_custom_css| for wizeditor replace it-->


<style id="wiz_custom_css">        html, body {            font-size: 15px;        }        body {            font-family: Helvetica, 'Hiragino Sans GB', '微软雅黑', 'Microsoft YaHei UI', SimSun, SimHei, arial, sans-serif;            line-height: 1.6;            margin: 0;            padding: 20px 36px;            padding: 1.33rem 2.4rem;        }        h1, h2, h3, h4, h5, h6 {            margin: 20px 0 10px;            margin: 1.33rem 0 0.667rem;            padding: 0;            font-weight: bold;        }        h1 {            font-size: 21px;            font-size: 1.4rem;        }        h2 {            font-size: 20px;            font-size: 1.33rem;        }        h3 {            font-size: 18px;            font-size: 1.2rem;        }        h4 {            font-size: 17px;            font-size: 1.13rem;        }        h5 {            font-size: 15px;            font-size: 1rem;        }        h6 {            font-size: 15px;            font-size: 1rem;            color: #777777;            margin: 1rem 0;        }        div, p, ul, ol, dl, li {            margin: 0;        }        blockquote, table, pre, code{            margin: 8px 0;        }        ul, ol {            padding-left: 32px;            padding-left: 2.13rem;        }        blockquote {            border-left: 4px solid #dddddd;            padding: 0 12px;            padding: 0 0.8rem;            color: #aaa;        }        blockquote > :first-child {            margin-top: 0;        }        blockquote > :last-child {            margin-bottom: 0;        }        img {            border: 0;            max-width: 100%;            height: auto !important;            margin: 2px 0;        }        table {            border-collapse: collapse;            border: 1px solid #bbbbbb;        }        td {            padding:4px 8px;            border-collapse: collapse;            border: 1px solid #bbbbbb;        }        @media screen and (max-width: 660px) {            body {                padding: 20px 18px;                padding: 1.33rem 1.2rem;            }        }        @media only screen and (-webkit-max-device-width: 1024px), only screen and (-o-max-device-width: 1024px), only screen and (max-device-width: 1024px), only screen and (-webkit-min-device-pixel-ratio: 3), only screen and (-o-min-device-pixel-ratio: 3), only screen and (min-device-pixel-ratio: 3) {            html, body {                font-size: 17px;            }            body {                line-height: 1.7;                padding: 0.75rem 0.9375rem;                color: #353c47;            }            h1 {                font-size: 2.125rem;            }            h2 {                font-size: 1.875rem;            }            h3 {                font-size: 1.625rem;            }            h4 {                font-size: 1.375rem;            }            h5 {                font-size: 1.125rem;            }            h6 {                color: inherit;            }            ul, ol {                padding-left: 2.5rem;            }            blockquote {                border-left: 4px solid #c8d4e8;                padding: 0 0.9375rem;                color: #b3c2dd;            }        }</style><style type="text/css" id="wiz_todo_style_id" wiz_link_version="01.00.09">.wiz-todo, .wiz-todo-img {width: 16px; height: 16px; cursor: default; padding: 0 10px 0 2px; vertical-align: -10%;-webkit-user-select: none;} .wiz-todo-label { display: inline-block; padding-top: 7px; padding-bottom: 6px; line-height: 1.5;} .wiz-todo-label-checked {  color: #666;} .wiz-todo-label-unchecked {text-decoration: initial;} .wiz-todo-completed-info {padding-left: 44px; display: inline-block; } .wiz-todo-avatar { width:20px; height: 20px; vertical-align: -20%; margin-right:10px; border-radius: 2px;} .wiz-todo-account, .wiz-todo-dt { color: #666; }</style></head>

<body  style=""><h2 style="font-size: 18px; letter-spacing: -1px; margin-top: 0px; margin-bottom: 0px; padding-top: 6px; padding-bottom: 6px; font-weight: normal; line-height: 21.6px; color: rgb(51, 51, 51); font-family: Verdana, 'Lucida Grande', Geneva, Arial, sans-serif; widows: 1; background-image: url(&quot;&quot;); background-color: rgb(255, 255, 255); background-position: 0% 100%; background-repeat: repeat no-repeat;"><a id="cb_post_title_url" href="http://www.cnblogs.com/hyddd/archive/2010/04/08/1706863.html" style="outline: none; text-decoration: none; color: rgb(102, 153, 204);">【转】高效使用vim</a></h2><small style="font-size: 12px; color: rgb(171, 171, 171); display: block; text-align: right; font-family: Verdana, 'Lucida Grande', Geneva, Arial, sans-serif; line-height: 18px; widows: 1; background-color: rgb(255, 255, 255);">2010-04-08 01:24 by hyddd,&nbsp;<span id="post_view_count">3090</span>&nbsp;阅读,&nbsp;<span id="post_comment_count">1</span>&nbsp;评论,&nbsp;<a href="http://www.cnblogs.com/hyddd/archive/2010/04/08/1706863.html#" style="outline: none; text-decoration: none; color: rgb(171, 171, 171);">收藏</a>,&nbsp;<a href="http://i.cnblogs.com/EditPosts.aspx?postid=1706863" rel="nofollow" style="outline: none; text-decoration: none; color: rgb(171, 171, 171);">编辑</a></small><div class="entry" style="font-size: 14px; font-family: Georgia, 'Times New Roman', Times, sans-serif; line-height: 1.8; word-break: break-all; color: rgb(51, 51, 51); widows: 1; background-color: rgb(255, 255, 255);"><div id="cnblogs_post_body" style="margin-bottom: 20px; word-break: break-word;">英文出处：<a href="http://jmcpherson.org/editing.html" target="_blank" style="outline: none; text-decoration: none; color: rgb(61, 129, 238);">jmcpherson.org/editing.html</a><br><div id="blog_text">翻译引用：<a href="http://tingsaode.spaces.live.com/blog/cns%21FE95D0EE01558610%21780.entry?wa=wsignin1.0&amp;sa=305465865" target="_blank" style="outline: none; text-decoration: none; color: rgb(61, 129, 238);">tingsaode.spaces.live.com/blog/cns!FE95D0EE01558610!780.entry</a><br>原文地址：<a target="_blank" href="http://hi.baidu.com/gone1210/blog/item/41c0e60b000230c33ac76328.html" style="outline: none; text-decoration: none; color: rgb(61, 129, 238);">http://hi.baidu.com/gone1210/blog/item/41c0e60b000230c33ac76328.html</a><br><strong style="background-color: rgb(106, 168, 79);"><p style="line-height: 1.8; margin: 10px auto;"><span style="line-height: 1.8; color: red; font-size: 14pt;">之于我, vi即禅.</span><br><span style="line-height: 1.8; color: red; font-size: 14pt;">用vi如修禅,</span><br><span style="line-height: 1.8; color: red; font-size: 14pt;">vi命令如禅之心印.</span><br><span style="line-height: 1.8; color: red; font-size: 14pt;">用者不可窥其堂奥,</span><br><span style="line-height: 1.8; color: red; font-size: 14pt;">门外汉视其晦涩如天书.</span><br><span style="line-height: 1.8; color: red; font-size: 14pt;">常用之, 实可知其道.</span><br><span style="line-height: 1.8; color: red; font-size: 14pt;"><br></span></p></strong><strong><span style="background-color: rgb(106, 168, 79);"><p style="line-height: 1.8; margin: 10px auto;"><span style="line-height: 1.8; color: rgb(255, 102, 0); font-size: 14pt;">高效移动</span><br><span style="line-height: 1.8; color: rgb(255, 102, 0); font-size: 14pt;">珍爱生命, 远离插入模式</span></p></span></strong><strong><p style="line-height: 1.8; margin: 10px auto;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 一般情况下, 你应该尽量少把时间花在插入模式, 因为在这种模式下vi和其它sb编辑器区别不大. 这也是大部分vim新手把大部分时间花在插入模式的原因 -- 插入模式很易用. 但是vim真正的优势在命令模式. 你会发现越了解vim, 你花在插入模式的时间越少.</p><p style="line-height: 1.8; margin: 10px auto;"><span style="line-height: 1.8; color: rgb(128, 128, 128); font-size: 12pt;">使用h,j,k, l</span></p><p style="line-height: 1.8; margin: 10px auto;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 高效率用vim编辑的第一步是绝了你用方向键(上下左右)的念头. vim设计出"模式"操作方式的一大优势就是可以让你不需要老是把手从方向键和字母键之间移来移去. 当你在命令模式下, 用字母h, j, k, l对应方向左, 下, 上, 右. 这个需要练习一下才能习惯, 但是你会发现一旦你习惯了它们, 比用方向键快多了. (译注: 这几个移动键一定要动手试, 然后反复用, 靠记忆忒艰难了)</p><p style="line-height: 1.8; margin: 10px auto;">&nbsp;&nbsp;&nbsp;&nbsp; 在你编辑电子邮件或其他段落式文本的时候, 你可能注意到移动方向跳的行数比你料想的多. 这是因为你的段落对vim来说在很长的同一个行里. 用h, j, k, l移动前输入g可以让移动相对于屏幕看上去的行数而不是vim内部的行数.</p><p style="line-height: 1.8; margin: 10px auto;"><span style="line-height: 1.8; font-size: 12pt; color: rgb(128, 128, 128);">用m</span><span style="line-height: 1.8; font-size: 12pt; color: rgb(128, 128, 128);">otio</span><span style="line-height: 1.8; font-size: 12pt; color: rgb(128, 128, 128);">n</span><span style="line-height: 1.8; font-size: 12pt; color: rgb(128, 128, 128);">在当前行移动&nbsp;</span><br style="color: rgb(153, 153, 153);"></p><p style="line-height: 1.8; margin: 10px auto;"><span style="line-height: 1.8; color: rgb(128, 128, 128);">(译注: 没想到特别合适的词翻译motion, 可以理解为"高级移动", 另请注意, motion仅在当前行移动)</span></p><p style="line-height: 1.8; margin: 10px auto;">&nbsp;&nbsp;&nbsp; 大部分编辑器只有简单的光标移动功能(上下左右, 行首行尾等等). vim有非常高级的光标移动命令, 这些命令叫做Motion. 当用motion把光标从文本中的一个点移动到另一个点的时候, 两点间的文本(包括两个点本身)被motion"掠过". (这个概念在接下来的教程中非常重要.) (译注: 举例说明一下"掠过"概念, 比如你有一行文本, 内容是abcdefg, 当前光标在c上, 如果你用motion $, 光标移动到了g上, 那么从c到g这段文本就被motion $"掠过"了).</p><p style="line-height: 1.8; margin: 10px auto;"><span style="line-height: 1.8; color: rgb(128, 128, 128);">以</span><span style="line-height: 1.8; color: rgb(128, 128, 128);">下是一些有用的motion:</span></p><table width="593" border="1" cellpadding="0" cellspacing="0" height="257" style="border-color: silver; word-break: break-word;"><tbody><tr><td valign="top" width="33" style="border-color: silver; padding: 3px;"><p style="line-height: 1.8; margin: 10px auto;"><span style="line-height: 1.8; color: rgb(255, 102, 0);">fx</span></p></td><td valign="top" width="560" style="border-color: silver; padding: 3px;"><p style="line-height: 1.8; margin: 10px auto;"><span style="line-height: 1.8; color: rgb(255, 102, 0);">在当前行向前移动光标到下一个字符x (很明显, x可以是任意你想要移动到的字符). 这是一个超级有用的命令. 你可以输入;来重复前一个f命令.</span></p></td></tr><tr><td valign="top" width="33" style="border-color: silver; padding: 3px;"><p style="line-height: 1.8; margin: 10px auto;"><span style="line-height: 1.8; color: rgb(255, 102, 0);">tx</span></p></td><td valign="top" width="560" style="border-color: silver; padding: 3px;"><p style="line-height: 1.8; margin: 10px auto;"><span style="line-height: 1.8; color: rgb(255, 102, 0);">和上面的命令基本相同, 除了移动光标到字符x之前而不是x字符本身. (这个真的很有用)</span></p></td></tr><tr><td valign="top" width="33" style="border-color: silver; padding: 3px;"><p style="line-height: 1.8; margin: 10px auto;"><span style="line-height: 1.8; color: rgb(255, 102, 0);">Fx</span></p></td><td valign="top" width="560" style="border-color: silver; padding: 3px;"><p style="line-height: 1.8; margin: 10px auto;"><span style="line-height: 1.8; color: rgb(255, 102, 0);">在当前行向后移动光标到上一个字符x.</span></p></td></tr><tr><td valign="top" width="33" style="border-color: silver; padding: 3px;"><p style="line-height: 1.8; margin: 10px auto;"><span style="line-height: 1.8; color: rgb(255, 102, 0);">w</span></p></td><td valign="top" width="560" style="border-color: silver; padding: 3px;"><p style="line-height: 1.8; margin: 10px auto;"><span style="line-height: 1.8; color: rgb(255, 102, 0);">将光标向前移动一个词.</span></p></td></tr><tr><td valign="top" width="33" style="border-color: silver; padding: 3px;"><p style="line-height: 1.8; margin: 10px auto;"><span style="line-height: 1.8; color: rgb(255, 102, 0);">b</span></p></td><td valign="top" width="560" style="border-color: silver; padding: 3px;"><p style="line-height: 1.8; margin: 10px auto;"><span style="line-height: 1.8; color: rgb(255, 102, 0);">将光标向后移动一个词.</span></p></td></tr><tr><td valign="top" width="33" style="border-color: silver; padding: 3px;"><p style="line-height: 1.8; margin: 10px auto;"><span style="line-height: 1.8; color: rgb(255, 102, 0);">0</span></p></td><td valign="top" width="560" style="border-color: silver; padding: 3px;"><p style="line-height: 1.8; margin: 10px auto;"><span style="line-height: 1.8; color: rgb(255, 102, 0);">将光标移动到当前行首.</span></p></td></tr><tr><td valign="top" width="33" style="border-color: silver; padding: 3px;"><p style="line-height: 1.8; margin: 10px auto;"><span style="line-height: 1.8; color: rgb(255, 102, 0);">^</span></p></td><td valign="top" width="560" style="border-color: silver; padding: 3px;"><p style="line-height: 1.8; margin: 10px auto;"><span style="line-height: 1.8; color: rgb(255, 102, 0);">将光标移动到当前行的第一个字符. (译注: 第一个字符可能不是行首, 比如行首有space, tab等不可见符号, 0会把光标停在这些符号之前, 而^会把光jk标停在这些符号之后的第一个可见字符.)</span></p></td></tr><tr><td valign="top" width="33" style="border-color: silver; padding: 3px;"><p style="line-height: 1.8; margin: 10px auto;"><span style="line-height: 1.8; color: rgb(255, 102, 0);">$</span></p></td><td valign="top" width="560" style="border-color: silver; padding: 3px;"><p style="line-height: 1.8; margin: 10px auto;"><span style="line-height: 1.8; color: rgb(255, 102, 0);">将光标移动到当前行尾.</span></p></td></tr><tr><td valign="top" width="33" style="border-color: silver; padding: 3px;"><p style="line-height: 1.8; margin: 10px auto;"><span style="line-height: 1.8; color: rgb(255, 102, 0);">)</span></p></td><td valign="top" width="560" style="border-color: silver; padding: 3px;"><p style="line-height: 1.8; margin: 10px auto;"><span style="line-height: 1.8; color: rgb(255, 102, 0);">将光标移动到下一个句子. (写电子邮件或者文本文档的时候很有用.)</span></p></td></tr><tr><td valign="top" width="33" style="border-color: silver; padding: 3px;"><p style="line-height: 1.8; margin: 10px auto;"><span style="line-height: 1.8; color: rgb(255, 102, 0);">(</span></p></td><td valign="top" width="560" style="border-color: silver; padding: 3px;"><p style="line-height: 1.8; margin: 10px auto;"><span style="line-height: 1.8; color: rgb(255, 102, 0);">将光标移动到上一个句子.</span></p></td></tr></tbody></table><p style="line-height: 1.8; margin: 10px auto;"><span style="line-height: 1.8; font-size: 14pt; color: rgb(255, 102, 0);">在文件中高效移动</span></p><p style="line-height: 1.8; margin: 10px auto;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; vim有很多命令可以让你在文件中任意移动光标 -- 很少需要手工一页一页滚动. 以下按键技术上说不算motion, 因为它们是在文件中移动, 而不是在某一特定的行.</p><table width="595" border="1" cellpadding="0" cellspacing="0" style="border-color: silver; word-break: break-word;"><tbody><tr><td valign="top" width="52" style="border-color: silver; padding: 3px;"><span style="color: rgb(255, 102, 0);">&lt;C-F&gt;</span></td><td valign="top" width="541" style="border-color: silver; padding: 3px;"><span style="color: rgb(255, 102, 0);">将光标向前(下)移动一页(屏幕).</span></td></tr><tr><td valign="top" width="52" style="border-color: silver; padding: 3px;"><span style="color: rgb(255, 102, 0);">&lt;C-B&gt;</span></td><td valign="top" width="541" style="border-color: silver; padding: 3px;"><span style="color: rgb(255, 102, 0);">将光标向后(上)移动一页.</span></td></tr><tr><td valign="top" width="52" style="border-color: silver; padding: 3px;"><span style="color: rgb(255, 102, 0);">G</span></td><td valign="top" width="541" style="border-color: silver; padding: 3px;"><span style="color: rgb(255, 102, 0);">移动到文件尾</span></td></tr><tr><td valign="top" width="52" style="border-color: silver; padding: 3px;"><span style="color: rgb(255, 102, 0);">numG</span></td><td valign="top" width="541" style="border-color: silver; padding: 3px;"><span style="color: rgb(255, 102, 0);">将光标移动到某一行. (例如, 10G是把光标移动到第10行.)</span></td></tr><tr><td valign="top" width="52" style="border-color: silver; padding: 3px;"><span style="color: rgb(255, 102, 0);">gg</span></td><td valign="top" width="541" style="border-color: silver; padding: 3px;"><span style="color: rgb(255, 102, 0);">将光标移动到文件开头</span></td></tr><tr><td valign="top" width="52" style="border-color: silver; padding: 3px;"><span style="color: rgb(255, 102, 0);">H</span></td><td valign="top" width="541" style="border-color: silver; padding: 3px;"><span style="color: rgb(255, 102, 0);">将光标移动到当前页的第一行.</span></td></tr><tr><td valign="top" width="52" style="border-color: silver; padding: 3px;"><span style="color: rgb(255, 102, 0);">M</span></td><td valign="top" width="541" style="border-color: silver; padding: 3px;"><span style="color: rgb(255, 102, 0);">将光标移动到当前页的中间一行.</span></td></tr><tr><td valign="top" width="52" style="border-color: silver; padding: 3px;"><span style="color: rgb(255, 102, 0);">L</span></td><td valign="top" width="541" style="border-color: silver; padding: 3px;"><span style="color: rgb(255, 102, 0);">将光标移动到当前页的最后一行. (译注: 有了HML3个命令, 可以把鼠标撇了, 爽)</span></td></tr><tr><td valign="top" width="52" style="border-color: silver; padding: 3px;"><span style="color: rgb(255, 102, 0);">*</span></td><td valign="top" width="541" style="border-color: silver; padding: 3px;"><span style="color: rgb(255, 102, 0);">读取光标下的字串, 然后移动到当前文件中下一次出现该字串的位置. (比如说如果你的光标所在的位置的字串为"bob,", 按了*之后, 光标将移动文件中下一个"bob"出现的位置.)</span></td></tr><tr><td valign="top" width="52" style="border-color: silver; padding: 3px;"><span style="color: rgb(255, 102, 0);">#</span></td><td valign="top" width="541" style="border-color: silver; padding: 3px;"><span style="color: rgb(255, 102, 0);">和*命令基本相同, 除了它移动到上一次出现字串的位置.</span></td></tr><tr><td valign="top" width="52" style="border-color: silver; padding: 3px;"><span style="color: rgb(255, 102, 0);">/</span><em style="color: rgb(255, 102, 0);">text&nbsp;</em><span style="color: rgb(255, 102, 0);">&nbsp;</span>&nbsp;</td><td valign="top" width="541" style="border-color: silver; padding: 3px;"><span style="color: rgb(255, 102, 0);">从当前光标位置开始, 查找下一个含有text的字串并且移动到那里. 需要按回车(Enter)键来执行查找. 如果要重复执行查找, 输入n(n代表next occurance). (译注: text指你想搜索的字串, 比如你要在文件查找字串"abc", 就输入/abc然后回车)</span></td></tr><tr><td valign="top" width="52" style="border-color: silver; padding: 3px;"><span style="color: rgb(255, 102, 0);">?</span><em style="color: rgb(255, 102, 0);">text</em><span style="color: rgb(255, 102, 0);">&nbsp;&nbsp;&nbsp;</span></td><td valign="top" width="541" style="border-color: silver; padding: 3px;"><span style="color: rgb(255, 102, 0);">和/text相似, 区别是?text进行反向查找(查找上一个字串).</span></td></tr><tr><td valign="top" width="52" style="border-color: silver; padding: 3px;"><span style="color: rgb(255, 102, 0);">ma</span></td><td valign="top" width="541" style="border-color: silver; padding: 3px;"><span style="color: rgb(255, 102, 0);">给当前光标所在位置设置一个名字为a的书签. 书签的名字可以是任何小写字母. 你看不到书签, 但它确实在.</span></td></tr><tr><td valign="top" width="52" style="border-color: silver; padding: 3px;"><span style="color: rgb(255, 102, 0);">`a</span></td><td valign="top" width="541" style="border-color: silver; padding: 3px;"><span style="color: rgb(255, 102, 0);">移动光标到书签a. 注意`不是单引号, 大部分键盘上它在数字1的左面. (译注: 本人使用的vim 7.1 windows版本用单引号也能完成同样功能)</span></td></tr><tr><td valign="top" width="52" style="border-color: silver; padding: 3px;"><span style="color: rgb(255, 102, 0);">`.</span></td><td valign="top" width="541" style="border-color: silver; padding: 3px;"><span style="color: rgb(255, 102, 0);">移动到你之前编辑过的行. 这个又是"真有用". 如果你需要在文件中"滚来滚去"查看一些东西, 你可以用这个命令回到你之前编辑的行尽管你没把它设成书签.</span></td></tr></tbody></table><p style="line-height: 1.8; margin: 10px auto;"><span style="line-height: 1.8; color: rgb(255, 102, 0); font-size: 14pt;">高效输入</span><br><span style="line-height: 1.8; color: rgb(255, 102, 0); font-size: 14pt;">使用关键字自动完成(补全)</span></p><p style="line-height: 1.8; margin: 10px auto;">&nbsp;&nbsp;&nbsp;&nbsp; vim 有个非常好的关键字自动完成系统. 就是说你可以只输入很长的词的一部分, 按一个键, vim帮你把这个词自动补全. 比如说在你的代码中有一个变量叫iAmALongAndAwkwardVarName, 你可能不愿意每次用这个变量都把整个词打一遍, 这时候就可以用自动完成功能.</p><p style="line-height: 1.8; margin: 10px auto;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 要使用关键字自动完成, 只要输入一个字串的前几个字母 (比如 iAmAL) 然后按 &lt;C-N&gt; (按住Ctrl然后按N&gt;)或者&lt;C-P&gt;. 如果vim没有选择你需要的字串, 继续按&lt;C-N&gt;或&lt;C-P&gt; -- vim会遍历所有和你输入的前几个字母匹配的字串.</p><p style="line-height: 1.8; margin: 10px auto;"><span style="line-height: 1.8; font-size: 14pt; color: rgb(255, 102, 0);">用点脑子开始插入模式</span></p><p style="line-height: 1.8; margin: 10px auto;">&nbsp;&nbsp;&nbsp;&nbsp; 大部分新用户输入i来进入插入模式. 这种方法有时候相当低效, vi有一堆可以高效进入插入模式的命令. 这里是最常用的一些:</p><table width="596" border="1" cellpadding="0" cellspacing="0" style="border-color: silver; word-break: break-word;"><tbody><tr><td valign="top" width="77" style="border-color: silver; padding: 3px;"><span style="color: rgb(255, 102, 0);">i</span></td><td valign="top" width="517" style="border-color: silver; padding: 3px;"><span style="color: rgb(255, 102, 0);">在当前字符的左侧开始插入.</span></td></tr><tr><td valign="top" width="77" style="border-color: silver; padding: 3px;"><span style="color: rgb(255, 102, 0);">I</span></td><td valign="top" width="517" style="border-color: silver; padding: 3px;"><span style="color: rgb(255, 102, 0);">在当前行行首开始插入.</span></td></tr><tr><td valign="top" width="77" style="border-color: silver; padding: 3px;"><span style="color: rgb(255, 102, 0);">a</span></td><td valign="top" width="517" style="border-color: silver; padding: 3px;"><span style="color: rgb(255, 102, 0);">在当前字符的右侧开始插入.</span></td></tr><tr><td valign="top" width="77" style="border-color: silver; padding: 3px;"><span style="color: rgb(255, 102, 0);">A</span></td><td valign="top" width="517" style="border-color: silver; padding: 3px;"><span style="color: rgb(255, 102, 0);">在当前行行尾开始插入.</span></td></tr><tr><td valign="top" width="77" style="border-color: silver; padding: 3px;"><span style="color: rgb(255, 102, 0);">o</span></td><td valign="top" width="517" style="border-color: silver; padding: 3px;"><span style="color: rgb(255, 102, 0);">在当前行的下一行开始新的一行并在那插入. (译注, 写code用这个很爽)</span></td></tr><tr><td valign="top" width="77" style="border-color: silver; padding: 3px;"><span style="color: rgb(255, 102, 0);">O</span></td><td valign="top" width="517" style="border-color: silver; padding: 3px;"><span style="color: rgb(255, 102, 0);">在当前行的上一行开始新的一行并在那插入.</span></td></tr><tr><td valign="top" width="77" style="border-color: silver; padding: 3px;"><span style="color: rgb(255, 102, 0);">c</span><em style="color: rgb(255, 102, 0);">{motion}</em></td><td valign="top" width="517" style="border-color: silver; padding: 3px;"><span style="color: rgb(255, 102, 0);">删除(change)motion"掠过"的文本然后插入新文本代替它. 比如说, c$会删除当前光标位置到当前行尾的文本并开始插入模式. ct!会删除当前光标位置到下一个!出现位置(不包括!本身)之间的文本并进入插入模式. 删除的文本会被复制到剪切板可以被粘贴使用. (译注: 可以到前面复习一下"掠过"的概念, 参考例子. 输入c{motion}命令的时候, 不需要输入花括号)</span></td></tr><tr><td valign="top" width="77" style="border-color: silver; padding: 3px;"><span style="color: rgb(255, 102, 0);">d</span><em style="color: rgb(255, 102, 0);">{motion}</em><span style="color: rgb(255, 102, 0);">&nbsp;</span></td><td valign="top" width="517" style="border-color: silver; padding: 3px;"><span style="color: rgb(255, 102, 0);">删除motion"掠过"的文本 -- 和c{motion}相似, 但是不进入插入模式.</span></td></tr></tbody></table><p style="line-height: 1.8; margin: 10px auto;"><span style="line-height: 1.8; color: rgb(255, 102, 0); font-size: 14pt;">高效移动成块的的文本</span><br><span style="line-height: 1.8; color: rgb(255, 102, 0); font-size: 14pt;">用可视化选择, 用合适的选中模式</span></p><p style="line-height: 1.8; margin: 10px auto;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 和最早的vi不同, vim可以让你把文本置为高亮然后对高亮的文本操作. 以下是主要的3个可视化选中模式 (即文本高亮模式).</p><table width="596" border="1" cellpadding="0" cellspacing="0" style="border-color: silver; word-break: break-word;"><tbody><tr><td valign="top" width="51" style="border-color: silver; padding: 3px;"><span style="color: rgb(255, 102, 0);">v</span></td><td valign="top" width="545" style="border-color: silver; padding: 3px;"><span style="color: rgb(255, 102, 0);">字符选中模式. 大部分人习惯用这个, 所以玩其他模式之前先把这个练熟.</span></td></tr><tr><td valign="top" width="51" style="border-color: silver; padding: 3px;"><span style="color: rgb(255, 102, 0);">V</span></td><td valign="top" width="545" style="border-color: silver; padding: 3px;"><span style="color: rgb(255, 102, 0);">行选中模式. 选中整行. 当你需要复制或移动几行的时候, 这个比字符选中模式要好.</span></td></tr><tr><td valign="top" width="51" style="border-color: silver; padding: 3px;"><span style="color: rgb(255, 102, 0);">&lt;C-V&gt;</span></td><td valign="top" width="545" style="border-color: silver; padding: 3px;"><span style="color: rgb(255, 102, 0);">块选中模式. 超级nb而且很少有其他的编辑器支持(译注: 还是有一些支持的, 比如ultraedit, 但是得付钱...). 你可以在任何文本中选择一个矩形块来操作. (译注: 在windows版本的vim中&lt;C-V&gt;默认被映射为粘贴, 可以通过更改键盘映射或者使用&lt;C-Q&gt;来进行块操作)</span></td></tr></tbody></table><p style="line-height: 1.8; margin: 10px auto;">&nbsp;&nbsp;&nbsp;&nbsp; 所有常用的光标移动键都可以在可视模式使用, 比如vwww会进入字符选中模式并且选中光标之后的3个词. Vjj将会进入行选中模式并且选中当前行及之后的两行.</p><p style="line-height: 1.8; margin: 10px auto;"><span style="line-height: 1.8; font-size: 14pt; color: rgb(255, 102, 0);">在可视化选中模式下进行剪切和复制</span></p><p style="line-height: 1.8; margin: 10px auto;">&nbsp;&nbsp;&nbsp;&nbsp; 一旦你有了高亮选择, 你可能想要干点啥. 以下是对选中的高亮文本最有用的命令:</p><table width="596" border="1" cellpadding="0" cellspacing="0" style="border-color: silver; word-break: break-word;"><tbody><tr><td valign="top" width="24" style="border-color: silver; padding: 3px;"><span style="color: rgb(255, 102, 0);">d</span></td><td valign="top" width="572" style="border-color: silver; padding: 3px;"><span style="color: rgb(255, 102, 0);">剪切(删除)高亮选中的文本到剪切板. (译注: 据本人所知, vim所有的删除其实都是剪切)</span></td></tr><tr><td valign="top" width="24" style="border-color: silver; padding: 3px;"><span style="color: rgb(255, 102, 0);">y</span></td><td valign="top" width="572" style="border-color: silver; padding: 3px;"><span style="color: rgb(255, 102, 0);">复制 (或者说"拽"(yank), vim用"拽"来表示复制...)高亮选中的文本到剪切板.</span></td></tr><tr><td valign="top" width="24" style="border-color: silver; padding: 3px;"><span style="color: rgb(255, 102, 0);">c</span></td><td valign="top" width="572" style="border-color: silver; padding: 3px;"><span style="color: rgb(255, 102, 0);">剪切高亮选中的文本到剪切板. 和d很相似, 只是c会进入插入模式.</span></td></tr></tbody></table><p style="line-height: 1.8; margin: 10px auto;"><span style="line-height: 1.8; color: rgb(255, 102, 0); font-size: 14pt;">在非可视化选择模式进行剪切和复制</span><br style="font-size: 14pt;">　　 如果你确知你想要复制或者剪切什么, 你可以不进入可视化选择模式就完成这些操作. 这样速度更快.</p><table width="596" border="1" cellpadding="0" cellspacing="0" style="border-color: silver; word-break: break-word;"><tbody><tr><td valign="top" width="79" style="border-color: silver; padding: 3px;"><span style="color: rgb(255, 102, 0);">d</span><em style="color: rgb(255, 102, 0);">{motion}</em></td><td valign="top" width="517" style="border-color: silver; padding: 3px;"><span style="color: rgb(255, 102, 0);">把由motion"掠过"的文本剪切到剪切板. 比如dw把当前光标开始的一个词剪切到剪切板, 而dfS把从当前行从光标是到下一个S之间的文本剪</span><span style="color: rgb(255, 102, 0);">切到剪切板.</span></td></tr><tr><td valign="top" width="79" style="border-color: silver; padding: 3px;"><span style="color: rgb(255, 102, 0);">y</span><em style="color: rgb(255, 102, 0);">{motion}</em><span style="color: rgb(255, 102, 0);">&nbsp;</span></td><td valign="top" width="517" style="border-color: silver; padding: 3px;"><span style="color: rgb(255, 102, 0);">把motion"掠过"的文本复制到剪切板.</span></td></tr><tr><td valign="top" width="79" style="border-color: silver; padding: 3px;"><span style="color: rgb(255, 102, 0);">c</span><em style="color: rgb(255, 102, 0);">{motion}</em><span style="color: rgb(255, 102, 0);">&nbsp;</span></td><td valign="top" width="517" style="border-color: silver; padding: 3px;"><span style="color: rgb(255, 102, 0);">把motion"掠过"的文本剪切到剪切板并且进入插入模式.</span></td></tr><tr><td valign="top" width="79" style="border-color: silver; padding: 3px;"><span style="color: rgb(255, 102, 0);">dd&nbsp;</span></td><td valign="top" width="517" style="border-color: silver; padding: 3px;"><span style="color: rgb(255, 102, 0);">剪切当前行到剪切板.</span></td></tr><tr><td valign="top" width="79" style="border-color: silver; padding: 3px;"><span style="color: rgb(255, 102, 0);">yy</span></td><td valign="top" width="517" style="border-color: silver; padding: 3px;"><span style="color: rgb(255, 102, 0);">复制当前行到剪切板.</span></td></tr><tr><td valign="top" width="79" style="border-color: silver; padding: 3px;"><span style="color: rgb(255, 102, 0);">cc</span></td><td valign="top" width="517" style="border-color: silver; padding: 3px;"><span style="color: rgb(255, 102, 0);">剪切当前行到剪切板并且进入插入模式.</span></td></tr><tr><td valign="top" width="79" style="border-color: silver; padding: 3px;"><span style="color: rgb(255, 102, 0);">D</span></td><td valign="top" width="517" style="border-color: silver; padding: 3px;"><span style="color: rgb(255, 102, 0);">剪切光标当前位置到行尾的文本到剪切板.</span></td></tr><tr><td valign="top" width="79" style="border-color: silver; padding: 3px;"><span style="color: rgb(255, 102, 0);">Y</span></td><td valign="top" width="517" style="border-color: silver; padding: 3px;"><span style="color: rgb(255, 102, 0);">复制整行到剪切板, 和yy相似. (yes, 这个命令和命令D的操作方式没保持一致, 你可以用y$完成类似D的操作)</span></td></tr><tr><td valign="top" width="79" style="border-color: silver; padding: 3px;"><span style="color: rgb(255, 102, 0);">C</span></td><td valign="top" width="517" style="border-color: silver; padding: 3px;"><span style="color: rgb(255, 102, 0);">剪切光标当前位置到行尾的文本到剪切板并进入插入模式.</span></td></tr><tr><td valign="top" width="79" style="border-color: silver; padding: 3px;"><span style="color: rgb(255, 102, 0);">x</span></td><td valign="top" width="517" style="border-color: silver; padding: 3px;"><span style="color: rgb(255, 102, 0);">剪切当前字符. (类似于命令模式的退格(backspace)键)</span></td></tr><tr><td valign="top" width="79" style="border-color: silver; padding: 3px;"><span style="color: rgb(255, 102, 0);">s</span></td><td valign="top" width="517" style="border-color: silver; padding: 3px;"><span style="color: rgb(255, 102, 0);">剪切当前字符并进入插入模式.</span></td></tr></tbody></table><p style="line-height: 1.8; margin: 10px auto;"><span style="line-height: 1.8; color: rgb(255, 102, 0); font-size: 12pt;">粘贴</span><br style="color: rgb(255, 102, 0);">　　<span style="line-height: 1.8; color: rgb(255, 102, 0); font-size: 12pt;">粘贴很简单. 把光标移动到你想要粘贴的位置输入p. (译注: 粘贴操作需要在命令模式下, 另外P(大写)命令把剪切板的内容粘贴到光标当前位置之前, 对用惯其它编辑器的人来说, P命令可能更符合习惯)</span></p><p style="line-height: 1.8; margin: 10px auto;">&nbsp;</p><p style="line-height: 1.8; margin: 10px auto;"><span style="line-height: 1.8; font-size: 14pt; color: rgb(255, 102, 0);">使用多个剪切板</span></p><p style="line-height: 1.8; margin: 10px auto;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 大部分编辑器只有一个剪切板. (译注: 貌似不算太'大部分') vim有多个. 在vim里剪切板叫做寄存器(regiseter). 你可以输入:reg列出所有当前定义过的寄存器和它们的内容. 大多数情况下你会使用以小写字母命名寄存器, 其他的有各自不同的vim内部用途, 偶尔可能会有用.</p><p style="line-height: 1.8; margin: 10px auto;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 要使用指定的某个寄存器来完成复制和粘贴, 很简单, 在复制粘贴操作之前输入"a, a表示你希望用的寄存器.</p><p style="line-height: 1.8; margin: 10px auto;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 举个例子, 复制当前行到寄存器k, 输入"kyy. (也可以用V"ky. 想想为啥这个也成). 那一行就会被存放在寄存器k里, 直到有其他的东西被复制到到寄存器k覆盖它. 复制之后可以用"kp来把寄存器k里存放的内容粘贴到到文本中.</p><p style="line-height: 1.8; margin: 10px auto;"><span style="line-height: 1.8; font-size: 14pt; color: rgb(255, 102, 0);">不干机械劳动</span><br><span style="line-height: 1.8; font-size: 14pt; color: rgb(255, 102, 0);">给你惊喜的.命令</span></p><p style="line-height: 1.8; margin: 10px auto;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 在vi中, 输入.(英文的句号)可以重复上一个你执行过的命令. 比如你上一个命令是dw, 当你输入.命令, vi会删除下一个词.</p><p style="line-height: 1.8; margin: 10px auto;"><span style="line-height: 1.8; color: rgb(255, 102, 0); font-size: 14pt;">使用计数器执行重复操作</span></p><p style="line-height: 1.8; margin: 10px auto;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 计数器是vim最nb的提速功能. 任何命令之前都可以加一个数. 这个数告诉vim你想把命令执行多少次. 例如:<br>3j会把光标向下移动3行.<br>10dd会删除10行文本.<br>y3"在当前行, 把光标当前位置到第三个双引号之间的文本复制到剪切板. 这种计数器用法可以大大扩展motion的操作范围. (译注: 本人认为y3"不能完成这样的功能, 对应的命令应该是y3f", 可能原作者漏写了f命令, 有空的时候问问原作者)</p><p style="line-height: 1.8; margin: 10px auto;"><span style="line-height: 1.8; color: rgb(255, 102, 0); font-size: 14pt;">录制宏</span></p><p style="line-height: 1.8; margin: 10px auto;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 你可能偶然会发现你对一个文档中的某块文本反反复复的进行相同的操作. vim可以录制一个特定的宏来完成这些操作.</p><table width="596" border="1" cellpadding="0" cellspacing="0" style="border-color: silver; word-break: break-word;"><tbody><tr><td valign="top" width="79" style="border-color: silver; padding: 3px;"><span style="color: rgb(255, 102, 0);">q</span><em style="color: rgb(255, 102, 0);">register</em><span style="color: rgb(255, 102, 0);">&nbsp;</span></td><td valign="top" width="517" style="border-color: silver; padding: 3px;"><span style="color: rgb(255, 102, 0);">开始录制一个宏并保存在某个有名字的寄存器. 比如qa开始录制一个宏并把这个宏存放在寄存器a中.</span></td></tr><tr><td valign="top" width="79" style="border-color: silver; padding: 3px;"><span style="color: rgb(255, 102, 0);">q</span></td><td valign="top" width="517" style="border-color: silver; padding: 3px;"><span style="color: rgb(255, 102, 0);">结束录制</span></td></tr><tr><td valign="top" width="79" style="border-color: silver; padding: 3px;"><span style="color: rgb(255, 102, 0);">@</span><em style="color: rgb(255, 102, 0);">register</em></td><td valign="top" width="517" style="border-color: silver; padding: 3px;"><span style="color: rgb(255, 102, 0);">回放存放在某个寄存器的宏. 比如@a播放寄存器a中的宏.</span></td></tr></tbody></table><p style="line-height: 1.8; margin: 10px auto;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 请注意宏只是记录你的按键并且回放; 不是神奇的魔法. 因为在vim中可以用多个命令执行某个任务, 录制宏几乎成了一种艺术形式, 你必须非常小心的选择要用的命令才能用宏达到你想要的效果.</p><p style="line-height: 1.8; margin: 10px auto;"><span style="line-height: 1.8; color: rgb(255, 102, 0); font-size: 14pt;">用vim写程序代码</span></p><p style="line-height: 1.8; margin: 10px auto;">&nbsp;&nbsp;&nbsp; vim是优秀的源代码编辑器, 有很多的功能是专门为写程序设计的. 这里是一些常用的:</p><table width="596" border="1" cellpadding="0" cellspacing="0" style="border-color: silver; word-break: break-word;"><tbody><tr><td valign="top" width="39" style="border-color: silver; padding: 3px;"><span style="color: rgb(255, 102, 0);">]p</span></td><td valign="top" width="557" style="border-color: silver; padding: 3px;"><span style="color: rgb(255, 102, 0);">和p相似, 但是它可以自动调整粘贴的代码和已有的代码缩进. 试试吧.</span></td></tr><tr><td valign="top" width="39" style="border-color: silver; padding: 3px;"><span style="color: rgb(255, 102, 0);">%</span></td><td valign="top" width="557" style="border-color: silver; padding: 3px;"><span style="color: rgb(255, 102, 0);">把光标放在某个花括号{}, 中括号[]或者圆括号()上, 按%会把光标移动到与之对应的花括号, 中括号或者圆括号上. 对于修正多层嵌套逻辑代码块的括号解析问题来说, 这个功能堪称救人于水火之中.</span></td></tr><tr><td valign="top" width="39" style="border-color: silver; padding: 3px;"><span style="color: rgb(255, 102, 0);">&gt;&gt;</span></td><td valign="top" width="557" style="border-color: silver; padding: 3px;"><span style="color: rgb(255, 102, 0);">缩进高亮选中的代码. (对高亮选中请查看前面章节, 如果没有文本被高亮选中, 则将当前行缩进)</span></td></tr><tr><td valign="top" width="39" style="border-color: silver; padding: 3px;"><span style="color: rgb(255, 102, 0);">&lt;&lt;</span></td><td valign="top" width="557" style="border-color: silver; padding: 3px;"><span style="color: rgb(255, 102, 0);">和&gt;&gt;类似, 但是反方向(译注: 缩进是向右移动行, 反方向既向左移动).</span></td></tr><tr><td valign="top" width="39" style="border-color: silver; padding: 3px;"><span style="color: rgb(255, 102, 0);">gd</span></td><td valign="top" width="557" style="border-color: silver; padding: 3px;"><span style="color: rgb(255, 102, 0);">把光标移动到当前光标所在位置的函数或者变量的定义(definition)(或声明(declaration)).</span></td></tr><tr><td valign="top" width="39" style="border-color: silver; padding: 3px;"><span style="color: rgb(255, 102, 0);">K</span></td><td valign="top" width="557" style="border-color: silver; padding: 3px;"><span style="color: rgb(255, 102, 0);">打开当前光标所在词对应的手册页(man page). (比如你的光标当前在sleep这个词上, vim会显示sleep的手册页) (译注: 这个功能貌似只对vim的原生OS--unix上有用)</span></td></tr></tbody></table><p style="line-height: 1.8; margin: 10px auto;">(译注: 结合ctags, cscope之类的辅助工具, vim可以提供更强大的程序代码编写功能)</p></strong><br><div style="color:gray"><small>来源：&nbsp;<a href="http://www.cnblogs.com/hyddd/archive/2010/04/08/1706863.html">http://www.cnblogs.com/hyddd/archive/2010/04/08/1706863.html</a></small></div></div></div></div></body></html>