
<html><head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>避免锁定不恰当的同步对象。</title><style type="text/css" id="wiz_phone_default_css"> body {margin: 8px 12px;padding: 0;font-size: 17px;line-height: 1.5em;}p {letter-spacing:1.5px;text-indent: 2em;line-height: 1.5em;}</style>

<style type="text/css" id="wiz_todo_style_id" wiz_link_version="01.00.07">.wiz-todo, .wiz-todo-img {width: 16px; height: 16px; cursor: default; padding: 0 10px 0 2px; vertical-align: -10%;-webkit-user-select: none;} .wiz-todo-label {margin-top: 8px; margin-bottom: 8px; line-height: 1;} .wiz-todo-label-checked { /*text-decoration: line-through;*/ color: #666;} .wiz-todo-label-unchecked {text-decoration: initial;} .wiz-todo-completed-info {padding-left: 44px; display: inline-block; } .wiz-todo-avatar { width:20px; height: 20px; vertical-align: -20%; margin-right:10px; border-radius: 2px;} .wiz-todo-account, .wiz-todo-dt { color: #666; }</style>
<style type="text/css" id="wiz_custom_css">
body
{
    font-family: "Microsoft YaHei UI","Microsoft YaHei",SimSun,"Segoe UI",Tahoma,Helvetica,Sans-Serif,"Microsoft YaHei", Georgia,Helvetica,Arial,sans-serif,宋体, PMingLiU,serif;
    font-size: 10.5pt;
    line-height: 1.5;
}
html, body
{
    
    
}
h1 {
    font-size:1.5em;
    font-weight:bold;
}
h2 {
    font-size:1.4em;
    font-weight:bold;
}
h3 {
    font-size:1.3em;
    font-weight:bold;
}
h4 {
    font-size:1.2em;
    font-weight:bold;
}
h5 {
    font-size:1.1em;
    font-weight:bold;
}
h6 {
    font-size:1.0em;
    font-weight:bold;
}
img {
    border:0;
    max-width: 100%;
}
blockquote {
    margin-top:0px;
    margin-bottom:0px;
}

</style>
</head><body style="" ><div><span style="font-size: 10.5pt; line-height: 1.5;">避免锁定不恰当的同步对象。</span></div><div><span style="font-size: 10.5pt; line-height: 1.5;"><br></span></div><div><p style="margin: 10px 0px; padding: 0px; color: rgb(51, 51, 51); background-color: rgb(248, 248, 248); text-indent: 28px; font-family: 宋体; letter-spacing: normal; line-height: 28px;">锁定的是两个不同的syncObject，这等于完全没有达到两个线程锁定同一个对象的目的。要修正以上错误，只要将syncObject变成static就可以了。</p><p style="margin: 10px 0px; padding: 0px; color: rgb(51, 51, 51); background-color: rgb(248, 248, 248); text-indent: 28px; font-family: 宋体; letter-spacing: normal; line-height: 28px;">另外，思考一下lock(this)，我们同样不建议在代码中编写这样的代码。如果两个对象的实例分别执行了锁定的代码，实际锁定的也就会是两个对象，完全不能达到同步的目的。</p><p style="margin: 10px 0px; padding: 0px; color: rgb(51, 51, 51); background-color: rgb(248, 248, 248); text-indent: 28px; font-family: 宋体; letter-spacing: normal; line-height: 28px;">第二个注意事项：在非静态方法中，静态变量不应作为同步对象。也许有读者会问，前面曾说到，要修正第一个注意事项中的示例问题，需要将syncObject变成static。这似乎和本注意事项有矛盾。事实上，第一个注意事项中的示例代码仅仅出于演示的目的，在实际应用中，我们强烈建议不要编写此类代码。在编写多线程代码时，要遵循这样的一个原则：</p><p style="margin: 10px 0px; padding: 0px; background-color: rgb(248, 248, 248); text-indent: 28px; font-family: 宋体; letter-spacing: normal; line-height: 28px;"><span data-wiz-span="data-wiz-span" style="font-size: 12pt;"><font color="#ff0000">1- 类型的静态方法应当保证线程安全，非静态方法不需实现线程安全</font></span><font color="#333333">。</font></p><p style="margin: 10px 0px; padding: 0px; color: rgb(51, 51, 51); background-color: rgb(248, 248, 248); text-indent: 28px; font-family: 宋体; letter-spacing: normal; line-height: 28px;">FCL中的绝大部分类都遵循了这个原则。像上一个示例中，如果将syncObject变成static，就相当于让非静态方法具备了线程安全性，这带来的一个问题是，如果应用程序中该类型存在多个实例，在遇到这个锁的时候，它们都会产生同步，而这可能不是开发者所愿意看到的。第二个注意事项实际也可以归纳到第一个注意事项中。</p><p style="margin: 10px 0px; padding: 0px; background-color: rgb(248, 248, 248); text-indent: 28px; font-family: 宋体; letter-spacing: normal; line-height: 28px;"><font color="#333333">第三个注意事项：</font><font color="#ff0000"><span data-wiz-span="data-wiz-span" style="font-size: 12pt;">2-</span></font><font color="#333333">&nbsp;</font><span data-wiz-span="data-wiz-span" style="font-size: 12pt;"><font color="#ff0000">值类型对象不能作为同步对象</font></span><font color="#333333">。值类型在传递到另一个线程的时候，会创建一个副本，这相当于每个线程锁定的也是两个对象。因此，值类型对象不能作为同步对象。</font></p><p style="margin: 10px 0px; padding: 0px; background-color: rgb(248, 248, 248); text-indent: 28px; font-family: 宋体; letter-spacing: normal; line-height: 28px;"><font color="#333333">第四个注意事项：</font><span data-wiz-span="data-wiz-span" style="font-size: 12pt;"><font color="#ff0000">3-&nbsp;</font></span><font color="#ff0000"><span data-wiz-span="data-wiz-span" style="font-size: 12pt;">锁定字符串是完全没有必要的，而且相当危险</span></font><font color="#333333">。这整个过程看上去和值类型正好相反。字符串在CLR中会被暂存到内存里，如果有两个变量被分配了相同内容的字符串，那么这两个引用会被指向同一块内存。所以，如果有两个地方同时使用了lock(“abc”)，那么它们实际锁定的是同一个对象，这会导致整个应用程序被阻滞。</font></p><p style="margin: 10px 0px; padding: 0px; background-color: rgb(248, 248, 248); text-indent: 28px; font-family: 宋体; letter-spacing: normal; line-height: 28px;"><font color="#333333">第五个注意事项：</font><span data-wiz-span="data-wiz-span" style="font-size: 12pt;"><font color="#ff0000">4- 降低同步对象的可见性</font></span><font color="#333333">。可见</font><font color="#ff0000">范围最广的一种同步对象是typeof(SampleClass)</font><font color="#333333">。typeof方法所返回的结果（也就是类型的type）是SampleClass的所有实例所共有的，即：所有实例的type都指向typeof方法的结果。这样一来，如果我们lock(typeof(SampleClass))，当前应用程序中所有SampleClass的实例线程将会全部被同步。这样编码完全没有必要，而且这样的同步对象太开放了。</font></p><p style="margin: 10px 0px; padding: 0px; color: rgb(51, 51, 51); background-color: rgb(248, 248, 248); text-indent: 28px; font-family: 宋体; letter-spacing: normal; line-height: 28px;">一般来说，同步对象也不应该是一个公共变量或属性。在FCL的早期版本中，一些常用的集合类型（如ArrayList）提供了公共属性SyncRoot，让我们锁定以便进行一些线程安全的操作。所以你一定会觉得我们刚才的结论不正确。其实不然，ArrayList操作的大部分应用场景不涉及多线程同步，所以它的方法更多的是单线程应用场景。线程同步是一个非常耗时（低效）的操作。若ArrayList的所有非静态方法都要考虑线程安全，那么ArrayList完全可以将这个SyncRoot变成静态私有的。现在它将SyncRoot变为公开的，是让调用者自己去决定操作是否需要线程安全。我们在编写代码时，除非有这样的要求，否则就应该始终考虑降低同步对象的可见性，将同步对象藏起来，只开放给自己或自己的子类就够了（需要开放给子类的情况其实也不多）</p></div></body></html>