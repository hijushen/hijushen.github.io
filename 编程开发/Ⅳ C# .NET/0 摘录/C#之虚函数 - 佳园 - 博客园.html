<meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>C#之虚函数 - 佳园 - 博客园</title><?xml version="1.0" encoding="UTF-8"?>

<div><div><div><p>若一个实例方法声明前带有virtual关键字，那么这个方法就是虚方法。<br clear="none"/><strong>虚方法与非虚方法的最大不同是，虚方法的实现可以由派生类所取代</strong>，这种取代是通过方法的重写实现的（以后再讲）<br clear="none"/><strong>虚方法的特点:</strong><br clear="none"/>虚方法前不允许有static,abstract,或override修饰符<br clear="none"/>虚方法不能是私有的，因此不能使用private修饰符<br clear="none"/><strong>虚方法的执行：</strong><br clear="none"/>我们知道一般函数在编译时就静态地编译到了执行文件中，其相对地址在程序运行期间是不发生变化的，<br clear="none"/>而虚函数在编译期间是不被静态编译的，它的相对地址是不确定的，它会根据运行时期对象实例来动态判断要调用的函数，<br clear="none"/>其中那个申明时定义的类叫申明类，那个执行时实例化的类叫实例类。<br clear="none"/>如：A a =new B(); 其中A是申明类，B是实例类。<br clear="none"/>1.当调用一个对象的函数时，系统会直接去检查这个对象申明定义的类，即申明类，看所调用的函数是否为虚函数；<br clear="none"/>2.如果不是虚函数，那么它就直接执行该函数。而如果是一个虚函数，那么这个时候它就不会立刻执行该函数了，而是开始检查对象的实例类。<br clear="none"/>3.在这个实例类里，他会检查这个实例类的定义中是否有实现该虚函数或者重新实现该虚函数（通过override关键字）的方法，<br clear="none"/>如果有，它就不会再找了，而是马上执行该实例类中实现的虚函数的方法。而如果没有的话，系统就会不停地往上找实例类的父类，<br clear="none"/>并对父类重复刚才在实例类里的检查，直到找到第一个重载了该虚函数的父类为止，然后执行该父类里重载后的函数。<br clear="none"/>例1：<br clear="none"/></p>
<div><div><a shape="rect" href="#" title="复制代码"><en-media alt="复制代码" hash="51e409b11aa51c150090697429a953ed" type="image/gif"></en-media> </a></div>
<pre>    class A<br clear="none"/>    {<br clear="none"/>        public virtual void Sum()<br clear="none"/>        {<br clear="none"/>            Console.WriteLine(&quot;I am A Class,I am virtual sum().&quot;);<br clear="none"/>        }<br clear="none"/>    }<br clear="none"/>    class Program<br clear="none"/>    {<br clear="none"/>        static void Main(string[] args)<br clear="none"/>        {<br clear="none"/>             A a=new A();   // 定义一个a这个A类的对象.这个A就是a的申明类，实例化a对象,A是a的实例类   <br clear="none"/>             a.Sum();<br clear="none"/>             Console.Read();<br clear="none"/>        }<br clear="none"/>    }</pre>
<div><a shape="rect" href="#" title="复制代码"><en-media alt="复制代码" hash="51e409b11aa51c150090697429a953ed" type="image/gif"></en-media> </a></div></div>
<p> 执行a.Sum：<br clear="none"/>1.先检查申明类A 2.检查到是sum是虚拟方法 3.转去检查实例类A，结果是题本身 <br clear="none"/>4.执行实例类A中实现Sum的方法 5.输出结果 I am A Class,I am virtual sum(). 
<br clear="none"/>例2：<br clear="none"/></p>
<div><div><a shape="rect" href="#" title="复制代码"><en-media alt="复制代码" hash="51e409b11aa51c150090697429a953ed" type="image/gif"></en-media> </a></div>
<pre>class A<br clear="none"/>    {<br clear="none"/>        public virtual void Sum()<br clear="none"/>        {<br clear="none"/>            Console.WriteLine(&quot;I am A Class,I am virtual sum().&quot;);<br clear="none"/>        }<br clear="none"/>    }<br clear="none"/>    class B : A    <br clear="none"/>    {<br clear="none"/>        public override void Sum() // 重新实现了虚函数   <br clear="none"/>        {<br clear="none"/>            Console.WriteLine(&quot;I am B Class,I am override sum().&quot;);<br clear="none"/>        }  <br clear="none"/><br clear="none"/>    }<br clear="none"/>    class Program<br clear="none"/>    {<br clear="none"/>        static void Main(string[] args)<br clear="none"/>        {<br clear="none"/>             A a=new B();  // 定义一个a这个A类的对象.这个A就是a的申明类，实例化a对象,B是a的实例类              <br clear="none"/>             a.Sum();<br clear="none"/>             Console.Read();<br clear="none"/>        }<br clear="none"/>    }</pre>
<div><a shape="rect" href="#" title="复制代码"><en-media alt="复制代码" hash="51e409b11aa51c150090697429a953ed" type="image/gif"></en-media> </a></div></div>
<p>执行a.Sum：<br clear="none"/>1.先检查申明类A 2.检查到是虚拟方法 3.转去检查实例类B，有重写的方法 4.执行实例类B中的方法 5.输出结果 I am B Class,I am override sum().<br clear="none"/> 例3：<br clear="none"/></p>
<div><div><a shape="rect" href="#" title="复制代码"><en-media alt="复制代码" hash="51e409b11aa51c150090697429a953ed" type="image/gif"></en-media> </a></div>
<pre>    class A<br clear="none"/>    {<br clear="none"/>        public virtual void Sum()<br clear="none"/>        {<br clear="none"/>            Console.WriteLine(&quot;I am A Class,I am virtual sum().&quot;);<br clear="none"/>        }<br clear="none"/>    }<br clear="none"/>    class B : A    <br clear="none"/>    {<br clear="none"/>        public override void Sum() // 重新实现了虚函数   <br clear="none"/>        {<br clear="none"/>            Console.WriteLine(&quot;I am B Class,I am override sum().&quot;);<br clear="none"/>        }  <br clear="none"/><br clear="none"/>    }<br clear="none"/>    class C : B<br clear="none"/>    {<br clear="none"/><br clear="none"/>    }<br clear="none"/>    class Program<br clear="none"/>    {<br clear="none"/>        static void Main(string[] args)<br clear="none"/>        {<br clear="none"/>             A a=new C();// 定义一个a这个A类的对象.这个A就是a的申明类，实例化a对象,C是a的实例类              <br clear="none"/>             a.Sum();<br clear="none"/>             Console.Read();<br clear="none"/>        }<br clear="none"/>    }</pre>
<div><a shape="rect" href="#" title="复制代码"><en-media alt="复制代码" hash="51e409b11aa51c150090697429a953ed" type="image/gif"></en-media> </a></div></div>
<p>执行a.Sum：<br clear="none"/>1.先检查申明类A 2.检查到是虚拟方法 3.转去检查实例类C，无重写的方法 4.转去检查类C的父类B，有重写的方法<br clear="none"/> 5.执行父类B中的Sum方法 6.输出结果 I am B Class,I am override sum().  
<br clear="none"/>例4：<br clear="none"/></p>
<div><div><a shape="rect" href="#" title="复制代码"><en-media alt="复制代码" hash="51e409b11aa51c150090697429a953ed" type="image/gif"></en-media> </a></div>
<pre>   class A<br clear="none"/>    {<br clear="none"/>        public virtual void Sum()<br clear="none"/>        {<br clear="none"/>            Console.WriteLine(&quot;I am A Class,I am virtual sum().&quot;);<br clear="none"/>        }<br clear="none"/>    }<br clear="none"/>    class B : A    <br clear="none"/>    {<br clear="none"/>        public new void Sum() //覆盖父类里的同名函数，而不是重新实现  <br clear="none"/>        {<br clear="none"/>            Console.WriteLine(&quot;I am B Class,I am new sum().&quot;);<br clear="none"/>        }  <br clear="none"/><br clear="none"/>    }<br clear="none"/>    class Program<br clear="none"/>    {<br clear="none"/>        static void Main(string[] args)<br clear="none"/>        {<br clear="none"/>             A a=new B();<br clear="none"/>             a.Sum();<br clear="none"/>             Console.Read();<br clear="none"/>        }<br clear="none"/>    }</pre>
<div><a shape="rect" href="#" title="复制代码"><en-media alt="复制代码" hash="51e409b11aa51c150090697429a953ed" type="image/gif"></en-media> </a></div></div>
<p>执行a.Sum：<br clear="none"/>1.先检查申明类A 2.检查到是虚拟方法 3.转去检查实例类B，无重写的（这个地方要注意了，虽然B里有实现Sum()，但没有使用override关键字，所以不会被认为是重写） 4.转去检查类B的父类A，就为本身 5.执行父类A中的Sum方法 6.输出结果 I am A Class,I am virtual sum().  <br clear="none"/>那么如果在例4里，申明的是类B呢？<br clear="none"/></p>
<div><div><a shape="rect" href="#" title="复制代码"><en-media alt="复制代码" hash="51e409b11aa51c150090697429a953ed" type="image/gif"></en-media> </a></div>
<pre>    class A<br clear="none"/>    {<br clear="none"/>        public virtual void Sum()<br clear="none"/>        {<br clear="none"/>            Console.WriteLine(&quot;I am A Class,I am virtual sum().&quot;);<br clear="none"/>        }<br clear="none"/>    }<br clear="none"/>    class B : A    <br clear="none"/>    {<br clear="none"/>        public new void Sum() //覆盖父类里的同名函数，而不是重新实现  <br clear="none"/>        {<br clear="none"/>            Console.WriteLine(&quot;I am B Class,I am new sum().&quot;);<br clear="none"/>        }  <br clear="none"/><br clear="none"/>    }<br clear="none"/>    class Program<br clear="none"/>    {<br clear="none"/>        static void Main(string[] args)<br clear="none"/>        {<br clear="none"/>             B b=new B();<br clear="none"/>             b.Sum();<br clear="none"/>             Console.Read();<br clear="none"/>        }<br clear="none"/>    }</pre>
<div><a shape="rect" href="#" title="复制代码"><en-media alt="复制代码" hash="51e409b11aa51c150090697429a953ed" type="image/gif"></en-media> </a></div></div>
<p>执行B类里的Sum()，输出结果I am B Class,I am new sum(). <br clear="none"/><strong>可以使用抽象函数重写基类中的虚函数吗？</strong><br clear="none"/>答案是可以的。</p>
<div><div><a shape="rect" href="#" title="复制代码"><en-media alt="复制代码" hash="51e409b11aa51c150090697429a953ed" type="image/gif"></en-media> </a></div>
<pre>    class A<br clear="none"/>    {<br clear="none"/>        public virtual void PrintFriends()<br clear="none"/>        {<br clear="none"/>            Console.WriteLine(&quot;A.PrintFriends()&quot;);   <br clear="none"/>        }  <br clear="none"/>    }<br clear="none"/>    abstract class B : A    <br clear="none"/>    {<br clear="none"/>        public abstract override void PrintFriends();   //使用override 修饰符，表示抽象重写了基类中该函数的实现<br clear="none"/>    }<br clear="none"/>    abstract class C : A<br clear="none"/>    {<br clear="none"/>        public abstract new void PrintFriends();        //使用 new 修饰符显式声明，表示隐藏了基类中该函数的实现<br clear="none"/>    }<br clear="none"/></pre>
<div><a shape="rect" href="#" title="复制代码"><en-media alt="复制代码" hash="51e409b11aa51c150090697429a953ed" type="image/gif"></en-media> </a></div></div>
<p><strong>密封类可以有虚函数吗？<br clear="none"/></strong>可以，基类中的虚函数将隐式的转化为非虚函数，但密封类本身不能再增加新的虚函数</p>
<div><div><a shape="rect" href="#" title="复制代码"><en-media alt="复制代码" hash="51e409b11aa51c150090697429a953ed" type="image/gif"></en-media> </a></div>
<pre>    class A<br clear="none"/>    {<br clear="none"/>        public virtual void Fun()<br clear="none"/>        {<br clear="none"/>            Console.WriteLine(&quot;I am A.&quot;);<br clear="none"/>        }<br clear="none"/>    }<br clear="none"/>    sealed class Program:A<br clear="none"/>    {<br clear="none"/>        public override void Fun()<br clear="none"/>        {<br clear="none"/>            Console.WriteLine(&quot;I am B.&quot;);<br clear="none"/>        }<br clear="none"/>        static void Main(string[] args)<br clear="none"/>        {<br clear="none"/>            Program p = new Program();<br clear="none"/>            p.Fun();<br clear="none"/>            Console.Read();<br clear="none"/>        }<br clear="none"/>    }</pre>
<div><a shape="rect" href="#" title="复制代码"><en-media alt="复制代码" hash="51e409b11aa51c150090697429a953ed" type="image/gif"></en-media> </a></div></div></div></div></div>