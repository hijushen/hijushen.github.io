<meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>C # 中OOP特例</title><?xml version="1.0" encoding="UTF-8"?>


<div style="word-wrap: break-word; -webkit-nbsp-mode: space; -webkit-line-break: after-white-space;"><div style="font-size: 16px;">采用属性和字段，UML方式构图</div><div style="font-size: 16px;">1 &nbsp;必须使用公共的构造方法来实例化类</div><div style="font-size: 16px;">&nbsp; &nbsp; &nbsp;如果构造方法全部设置为私有的，将不能实例化类；</div><div style="font-size: 16px;">2 &nbsp;析构函数：</div><div style="font-size: 16px;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 释放资源，清理对象</div><div style="font-size: 16px;">大多数情况下，会垃圾回收机制会自动的释放不使用的类及其使用的对象。</div><div style="font-size: 16px;">但是特殊情况下，对象的存在，可能会导致某些 稀有资源的占有化，需要采用可删除的对象来解决此类问题。</div><div style="font-size: 16px;"><br/></div><div style="font-size: 16px;">3 &nbsp;静态的实例类成员</div><div style="font-size: 16px;">&nbsp; &nbsp; &nbsp;例如Console.WriteLine(),Convert.ToString()，他们都不需要实例化，强制实例化的话会导致报错，失败；因为构造函数不可以公共的访问；</div><div style="font-size: 16px;">应用：</div><div style="font-size: 16px;">&nbsp; &nbsp; &nbsp; 可使用静态属性跟踪到底类创立了多少个实例，UML中使用加下划线来表示</div><div style="font-size: 16px;"><u>+staticMethod:void &nbsp;。</u></div><div style="font-size: 16px;">静态类就是类似于java中的final</div><div style="font-size: 16px;"><br/></div><div style="font-size: 16px;">4 &nbsp;可删除对象 IDisposable, 必须实现Dispose()方法，可以提前释放重要稀有资源，而不是等到垃圾回收的时候。</div><div style="font-size: 16px;"><br/></div><div style="font-size: 16px;">5 &nbsp;接口之间可以实现多继承，可以更好的为类提供服务，接口中也可以预 &nbsp;定义方法，实现方法的封装。</div><div style="font-size: 16px;"><br/></div><div style="font-size: 16px;">值和引用的区别：引用可以是null类型。 &nbsp; 结构体是值类型</div><div style="font-size: 16px;">abstract 和 sealed （= final（：java））</div></div>